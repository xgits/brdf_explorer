; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+10
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	0c7H
	DW	0caH
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN187
	DD	imagerel $LN187+526
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflate_table DD imagerel $LN187+526
	DD	imagerel $LN187+1437
	DD	imagerel $chain$2$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflate_table DD imagerel $LN187+1437
	DD	imagerel $LN187+1444
	DD	imagerel $chain$4$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflate_table DD imagerel $LN187+1444
	DD	imagerel $LN187+1463
	DD	imagerel $chain$5$inflate_table
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflate_table DD 021H
	DD	imagerel $LN187
	DD	imagerel $LN187+526
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflate_table DD 060021H
	DD	0df400H
	DD	0ee400H
	DD	0fd400H
	DD	imagerel $LN187
	DD	imagerel $LN187+526
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflate_table DD 061821H
	DD	0df418H
	DD	0ee40dH
	DD	0fd405H
	DD	imagerel $LN187
	DD	imagerel $LN187+526
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 061b01H
	DD	0c014f21bH
	DD	060117012H
	DD	0300f5010H
; Function compile flags: /Ogtpy
; File G:\1_Projects\BRDF\DisneyBRDF\zlib-1.2.12\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
match$1$ = 0
mask$1$ = 8
tv1879 = 12
extra$2$ = 16
base$2$ = 24
count$ = 32
offs$ = 64
type$ = 176
lens$ = 184
here$ = 192
codes$ = 192
table$ = 200
bits$ = 208
work$ = 216
inflate_table PROC					; COMDAT

; 39   : {

$LN187:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	53		 push	 rbx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 199, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  0001b	45 33 e4	 xor	 r12d, r12d
  0001e	41 8b d8	 mov	 ebx, r8d
  00021	45 0f b7 d4	 movzx	 r10d, r12w
  00025	49 8b f1	 mov	 rsi, r9
  00028	41 8b c2	 mov	 eax, r10d
  0002b	48 8b ea	 mov	 rbp, rdx
  0002e	41 c1 e2 10	 shl	 r10d, 16
  00032	8b f9		 mov	 edi, ecx
  00034	44 0b d0	 or	 r10d, eax
  00037	66 41 0f 6e c2	 movd	 xmm0, r10d
  0003c	66 0f 70 c0 00	 pshufd	 xmm0, xmm0, 0
  00041	0f 11 44 24 20	 movups	 XMMWORD PTR count$[rsp], xmm0
  00046	0f 11 44 24 30	 movups	 XMMWORD PTR count$[rsp+16], xmm0

; 108  :         count[len] = 0;
; 109  :     for (sym = 0; sym < codes; sym++)

  0004b	45 85 c0	 test	 r8d, r8d
  0004e	74 22		 je	 SHORT $LN6@inflate_ta
  00050	48 8b ca	 mov	 rcx, rdx
  00053	8b d3		 mov	 edx, ebx
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@inflate_ta:

; 110  :         count[lens[sym]]++;

  00060	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00063	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  00067	66 ff 44 44 20	 inc	 WORD PTR count$[rsp+rax*2]
  0006c	48 83 ea 01	 sub	 rdx, 1
  00070	75 ee		 jne	 SHORT $LL7@inflate_ta
$LN6@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00072	4c 8b 94 24 d0
	00 00 00	 mov	 r10, QWORD PTR bits$[rsp]
  0007a	ba 0d 00 00 00	 mov	 edx, 13

; 114  :     for (max = MAXBITS; max >= 1; max--)

  0007f	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00085	45 8b 02	 mov	 r8d, DWORD PTR [r10]
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL10@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00090	41 8b c1	 mov	 eax, r9d
  00093	66 44 39 64 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r12w
  00099	75 4f		 jne	 SHORT $LN78@inflate_ta
  0009b	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  0009e	66 44 39 64 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r12w
  000a4	75 41		 jne	 SHORT $LN130@inflate_ta
  000a6	8b c2		 mov	 eax, edx
  000a8	66 44 39 64 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r12w
  000ae	75 31		 jne	 SHORT $LN131@inflate_ta
  000b0	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  000b3	66 44 39 64 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r12w
  000b9	75 20		 jne	 SHORT $LN132@inflate_ta
  000bb	8d 42 fe	 lea	 eax, DWORD PTR [rdx-2]
  000be	66 44 39 64 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r12w
  000c4	75 0f		 jne	 SHORT $LN133@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000c6	41 83 c1 fb	 add	 r9d, -5			; fffffffbH
  000ca	83 c2 fb	 add	 edx, -5			; fffffffbH
  000cd	41 83 f9 01	 cmp	 r9d, 1
  000d1	73 bd		 jae	 SHORT $LL10@inflate_ta
  000d3	eb 15		 jmp	 SHORT $LN78@inflate_ta
$LN133@inflate_ta:

; 115  :         if (count[max] != 0) break;

  000d5	41 83 c1 fc	 add	 r9d, -4			; fffffffcH
  000d9	eb 0f		 jmp	 SHORT $LN78@inflate_ta
$LN132@inflate_ta:
  000db	41 83 c1 fd	 add	 r9d, -3			; fffffffdH
  000df	eb 09		 jmp	 SHORT $LN78@inflate_ta
$LN131@inflate_ta:
  000e1	41 83 c1 fe	 add	 r9d, -2			; fffffffeH
  000e5	eb 03		 jmp	 SHORT $LN78@inflate_ta
$LN130@inflate_ta:
  000e7	41 ff c9	 dec	 r9d
$LN78@inflate_ta:

; 116  :     if (root > max) root = max;
; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000ea	45 3b c1	 cmp	 r8d, r9d
  000ed	41 8b c9	 mov	 ecx, r9d
  000f0	41 0f 46 c8	 cmovbe	 ecx, r8d
  000f4	45 85 c9	 test	 r9d, r9d
  000f7	75 3b		 jne	 SHORT $LN37@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000f9	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000fc	c7 84 24 c0 00
	00 00 40 01 00
	00		 mov	 DWORD PTR here$[rsp], 320 ; 00000140H
  00107	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR here$[rsp]
  0010e	89 01		 mov	 DWORD PTR [rcx], eax
  00110	48 83 06 04	 add	 QWORD PTR [rsi], 4
  00114	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00117	89 01		 mov	 DWORD PTR [rcx], eax
  00119	48 83 06 04	 add	 QWORD PTR [rsi], 4

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;
; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  0011d	33 c0		 xor	 eax, eax
  0011f	41 c7 02 01 00
	00 00		 mov	 DWORD PTR [r10], 1

; 304  : }

  00126	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0012d	41 5c		 pop	 r12
  0012f	5f		 pop	 rdi
  00130	5e		 pop	 rsi
  00131	5d		 pop	 rbp
  00132	5b		 pop	 rbx
  00133	c3		 ret	 0
$LN37@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00134	41 bb 01 00 00
	00		 mov	 r11d, 1
  0013a	45 3b cb	 cmp	 r9d, r11d
  0013d	76 17		 jbe	 SHORT $LN173@inflate_ta
  0013f	48 8d 44 24 22	 lea	 rax, QWORD PTR count$[rsp+2]
$LL13@inflate_ta:

; 127  :         if (count[min] != 0) break;

  00144	66 44 39 20	 cmp	 WORD PTR [rax], r12w
  00148	75 0c		 jne	 SHORT $LN173@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  0014a	41 ff c3	 inc	 r11d
  0014d	48 83 c0 02	 add	 rax, 2
  00151	45 3b d9	 cmp	 r11d, r9d
  00154	72 ee		 jb	 SHORT $LL13@inflate_ta
$LN173@inflate_ta:

; 128  :     if (root < min) root = min;
; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  00156	41 3b cb	 cmp	 ecx, r11d
  00159	45 8b d3	 mov	 r10d, r11d

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  0015c	ba 01 00 00 00	 mov	 edx, 1
  00161	44 0f 43 d1	 cmovae	 r10d, ecx
  00165	44 8b c2	 mov	 r8d, edx
  00168	44 89 54 24 0c	 mov	 DWORD PTR tv1879[rsp], r10d
  0016d	0f 1f 00	 npad	 3
$LL16@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  00170	8b c2		 mov	 eax, edx
  00172	45 03 c0	 add	 r8d, r8d
  00175	0f b7 4c 44 20	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  0017a	44 2b c1	 sub	 r8d, ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0017d	0f 88 21 04 00
	00		 js	 $LN42@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00183	ff c2		 inc	 edx
  00185	83 fa 0f	 cmp	 edx, 15
  00188	76 e6		 jbe	 SHORT $LL16@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  0018a	45 85 c0	 test	 r8d, r8d
  0018d	7e 12		 jle	 SHORT $LN41@inflate_ta
  0018f	85 ff		 test	 edi, edi
  00191	0f 84 0d 04 00
	00		 je	 $LN42@inflate_ta
  00197	41 83 f9 01	 cmp	 r9d, 1
  0019b	0f 85 03 04 00
	00		 jne	 $LN42@inflate_ta
$LN41@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  001a1	66 44 89 64 24
	42		 mov	 WORD PTR offs$[rsp+2], r12w
  001a7	49 8b cc	 mov	 rcx, r12
  001aa	ba 0e 00 00 00	 mov	 edx, 14
  001af	90		 npad	 1
$LL19@inflate_ta:

; 142  :     for (len = 1; len < MAXBITS; len++)
; 143  :         offs[len + 1] = offs[len] + count[len];

  001b0	0f b7 44 0c 22	 movzx	 eax, WORD PTR count$[rsp+rcx+2]
  001b5	66 03 44 0c 42	 add	 ax, WORD PTR offs$[rsp+rcx+2]
  001ba	66 89 44 0c 44	 mov	 WORD PTR offs$[rsp+rcx+4], ax
  001bf	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  001c3	48 83 ea 01	 sub	 rdx, 1
  001c7	75 e7		 jne	 SHORT $LL19@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001c9	45 8b c4	 mov	 r8d, r12d
  001cc	85 db		 test	 ebx, ebx
  001ce	74 3e		 je	 SHORT $LN21@inflate_ta
  001d0	48 8b b4 24 d8
	00 00 00	 mov	 rsi, QWORD PTR work$[rsp]
  001d8	48 8b d5	 mov	 rdx, rbp
  001db	0f 1f 44 00 00	 npad	 5
$LL22@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  001e0	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001e3	66 85 c0	 test	 ax, ax
  001e6	74 12		 je	 SHORT $LN20@inflate_ta
  001e8	0f b7 4c 44 40	 movzx	 ecx, WORD PTR offs$[rsp+rax*2]
  001ed	66 44 89 04 4e	 mov	 WORD PTR [rsi+rcx*2], r8w
  001f2	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001f5	66 ff 44 44 40	 inc	 WORD PTR offs$[rsp+rax*2]
$LN20@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001fa	41 ff c0	 inc	 r8d
  001fd	48 83 c2 02	 add	 rdx, 2
  00201	44 3b c3	 cmp	 r8d, ebx
  00204	72 da		 jb	 SHORT $LL22@inflate_ta
  00206	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR table$[rsp]
$LN21@inflate_ta:
  0020e	4c 89 6c 24 78	 mov	 QWORD PTR [rsp+120], r13

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00213	45 8b ec	 mov	 r13d, r12d
  00216	4c 89 74 24 70	 mov	 QWORD PTR [rsp+112], r14
  0021b	41 be 01 00 00
	00		 mov	 r14d, 1
  00221	4c 89 7c 24 68	 mov	 QWORD PTR [rsp+104], r15
  00226	4c 8b 3e	 mov	 r15, QWORD PTR [rsi]
  00229	85 ff		 test	 edi, edi
  0022b	0f 84 f3 00 00
	00		 je	 $LN44@inflate_ta
  00231	41 3b fe	 cmp	 edi, r14d
  00234	41 8b da	 mov	 ebx, r10d
  00237	41 8b fc	 mov	 edi, r12d
  0023a	0f 84 98 00 00
	00		 je	 $LN45@inflate_ta

; 190  :         break;
; 191  :     default:    /* DISTS */
; 192  :         base = dbase;
; 193  :         extra = dext;
; 194  :         match = 0;
; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */
; 199  :     sym = 0;                    /* starting code symbol */
; 200  :     len = min;                  /* starting code length */
; 201  :     next = *table;              /* current table to fill in */
; 202  :     curr = root;                /* current table index bits */
; 203  :     drop = 0;                   /* current bits to drop from code for index */
; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 205  :     used = 1U << root;          /* use root table entries */

  00240	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv1879[rsp]
  00244	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:?dbase@?1??inflate_table@@9@9
  0024b	41 d3 e6	 shl	 r14d, cl
  0024e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9

; 206  :     mask = used - 1;            /* mask for comparing low */
; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  00255	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  0025d	48 8b f5	 mov	 rsi, rbp
  00260	48 89 6c 24 18	 mov	 QWORD PTR base$2$[rsp], rbp
  00265	41 bc ff ff ff
	ff		 mov	 r12d, -1		; ffffffffH
  0026b	48 89 44 24 10	 mov	 QWORD PTR extra$2$[rsp], rax
  00270	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  00277	41 8d 4e ff	 lea	 ecx, DWORD PTR [r14-1]
  0027b	89 3c 24	 mov	 DWORD PTR match$1$[rsp], edi
  0027e	89 4c 24 08	 mov	 DWORD PTR mask$1$[rsp], ecx
  00282	41 8b c6	 mov	 eax, r14d
  00285	0f 84 85 00 00
	00		 je	 $LN176@inflate_ta
  0028b	45 33 f6	 xor	 r14d, r14d
  0028e	48 89 74 24 18	 mov	 QWORD PTR base$2$[rsp], rsi
  00293	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  0029b	44 89 34 24	 mov	 DWORD PTR match$1$[rsp], r14d
  0029f	44 8b f0	 mov	 r14d, eax
  002a2	48 89 6c 24 10	 mov	 QWORD PTR extra$2$[rsp], rbp
  002a7	89 4c 24 08	 mov	 DWORD PTR mask$1$[rsp], ecx
  002ab	0f 85 ac 00 00
	00		 jne	 $LN175@inflate_ta
  002b1	48 89 74 24 18	 mov	 QWORD PTR base$2$[rsp], rsi
  002b6	33 f6		 xor	 esi, esi
  002b8	48 89 6c 24 10	 mov	 QWORD PTR extra$2$[rsp], rbp
  002bd	8b ee		 mov	 ebp, esi
  002bf	89 34 24	 mov	 DWORD PTR match$1$[rsp], esi
  002c2	89 4c 24 08	 mov	 DWORD PTR mask$1$[rsp], ecx
  002c6	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
  002cb	0f 87 cc 02 00
	00		 ja	 $LN62@inflate_ta
  002d1	8b d6		 mov	 edx, esi
  002d3	e9 89 00 00 00	 jmp	 $LL25@inflate_ta
$LN45@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;

  002d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 188  :         extra = lext;
; 189  :         match = 257;

  002df	c7 04 24 01 01
	00 00		 mov	 DWORD PTR match$1$[rsp], 257 ; 00000101H
  002e6	48 89 44 24 18	 mov	 QWORD PTR base$2$[rsp], rax
  002eb	41 8b ca	 mov	 ecx, r10d
  002ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  002f5	41 d3 e6	 shl	 r14d, cl
  002f8	48 89 44 24 10	 mov	 QWORD PTR extra$2$[rsp], rax
  002fd	41 8b ec	 mov	 ebp, r12d
  00300	41 bc ff ff ff
	ff		 mov	 r12d, -1		; ffffffffH
  00306	41 8d 46 ff	 lea	 eax, DWORD PTR [r14-1]
  0030a	89 44 24 08	 mov	 DWORD PTR mask$1$[rsp], eax

; 206  :     mask = used - 1;            /* mask for comparing low */
; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  0030e	eb 02		 jmp	 SHORT $LN156@inflate_ta
$LN176@inflate_ta:
  00310	8b ef		 mov	 ebp, edi
$LN156@inflate_ta:
  00312	41 81 fe 54 03
	00 00		 cmp	 r14d, 852		; 00000354H
  00319	0f 87 7e 02 00
	00		 ja	 $LN62@inflate_ta
  0031f	8b 14 24	 mov	 edx, DWORD PTR match$1$[rsp]
  00322	eb 3d		 jmp	 SHORT $LL25@inflate_ta
$LN44@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  00324	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]

; 184  :         match = 20;

  0032c	ba 14 00 00 00	 mov	 edx, 20
  00331	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv1879[rsp]
  00335	41 8b ec	 mov	 ebp, r12d
  00338	41 d3 e6	 shl	 r14d, cl
  0033b	41 8b fc	 mov	 edi, r12d
  0033e	48 89 44 24 10	 mov	 QWORD PTR extra$2$[rsp], rax
  00343	8b d9		 mov	 ebx, ecx
  00345	48 89 44 24 18	 mov	 QWORD PTR base$2$[rsp], rax
  0034a	41 bc ff ff ff
	ff		 mov	 r12d, -1		; ffffffffH
  00350	89 14 24	 mov	 DWORD PTR match$1$[rsp], edx
  00353	41 8d 46 ff	 lea	 eax, DWORD PTR [r14-1]
  00357	89 44 24 08	 mov	 DWORD PTR mask$1$[rsp], eax

; 206  :     mask = used - 1;            /* mask for comparing low */
; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  0035b	eb 04		 jmp	 SHORT $LL25@inflate_ta
$LN175@inflate_ta:
  0035d	8b ef		 mov	 ebp, edi
  0035f	8b d7		 mov	 edx, edi
$LL25@inflate_ta:

; 210  :         (type == DISTS && used > ENOUGH_DISTS))
; 211  :         return 1;
; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);
; 217  :         if (work[sym] + 1U < match) {

  00361	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  00369	41 0f b6 c3	 movzx	 eax, r11b
  0036d	41 2a c5	 sub	 al, r13b
  00370	88 84 24 c1 00
	00 00		 mov	 BYTE PTR here$[rsp+1], al
  00377	8b c5		 mov	 eax, ebp
  00379	0f b7 0c 41	 movzx	 ecx, WORD PTR [rcx+rax*2]
  0037d	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  00380	3b c2		 cmp	 eax, edx
  00382	73 12		 jae	 SHORT $LN50@inflate_ta

; 218  :             here.op = (unsigned char)0;

  00384	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR here$[rsp], 0

; 219  :             here.val = work[sym];

  0038c	66 89 8c 24 c2
	00 00 00	 mov	 WORD PTR here$[rsp+2], cx

; 220  :         }

  00394	eb 36		 jmp	 SHORT $LN53@inflate_ta
$LN50@inflate_ta:

; 221  :         else if (work[sym] >= match) {

  00396	3b ca		 cmp	 ecx, edx
  00398	72 20		 jb	 SHORT $LN52@inflate_ta

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  0039a	48 8b 44 24 10	 mov	 rax, QWORD PTR extra$2$[rsp]
  0039f	2b ca		 sub	 ecx, edx
  003a1	48 03 c9	 add	 rcx, rcx
  003a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a8	88 84 24 c0 00
	00 00		 mov	 BYTE PTR here$[rsp], al

; 223  :             here.val = base[work[sym] - match];

  003af	48 8b 44 24 18	 mov	 rax, QWORD PTR base$2$[rsp]
  003b4	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]

; 224  :         }

  003b8	eb 0a		 jmp	 SHORT $LN184@inflate_ta
$LN52@inflate_ta:

; 225  :         else {
; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  003ba	c6 84 24 c0 00
	00 00 60	 mov	 BYTE PTR here$[rsp], 96	; 00000060H

; 227  :             here.val = 0;

  003c2	33 c0		 xor	 eax, eax
$LN184@inflate_ta:

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  003c4	66 89 84 24 c2
	00 00 00	 mov	 WORD PTR here$[rsp+2], ax
$LN53@inflate_ta:
  003cc	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR here$[rsp]
  003d3	41 8b cb	 mov	 ecx, r11d
  003d6	41 2b cd	 sub	 ecx, r13d
  003d9	41 ba 01 00 00
	00		 mov	 r10d, 1
  003df	41 d3 e2	 shl	 r10d, cl

; 232  :         fill = 1U << curr;

  003e2	ba 01 00 00 00	 mov	 edx, 1
  003e7	8b cb		 mov	 ecx, ebx
  003e9	44 8b c7	 mov	 r8d, edi
  003ec	d3 e2		 shl	 edx, cl
  003ee	41 8b cd	 mov	 ecx, r13d
  003f1	41 d3 e8	 shr	 r8d, cl
  003f4	44 03 c2	 add	 r8d, edx

; 233  :         min = fill;                 /* save offset to next table */

  003f7	8b f2		 mov	 esi, edx
  003f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL30@inflate_ta:

; 234  :         do {
; 235  :             fill -= incr;

  00400	45 2b c2	 sub	 r8d, r10d

; 236  :             next[(huff >> drop) + fill] = here;

  00403	43 89 04 87	 mov	 DWORD PTR [r15+r8*4], eax
  00407	41 2b d2	 sub	 edx, r10d

; 237  :         } while (fill != 0);

  0040a	75 f4		 jne	 SHORT $LL30@inflate_ta

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  0040c	41 8d 4b ff	 lea	 ecx, DWORD PTR [r11-1]
  00410	ba 01 00 00 00	 mov	 edx, 1
  00415	d3 e2		 shl	 edx, cl

; 241  :         while (huff & incr)

  00417	85 d7		 test	 edx, edi
  00419	74 0b		 je	 SHORT $LN32@inflate_ta
  0041b	0f 1f 44 00 00	 npad	 5
$LL31@inflate_ta:

; 242  :             incr >>= 1;

  00420	d1 ea		 shr	 edx, 1
  00422	85 d7		 test	 edx, edi
  00424	75 fa		 jne	 SHORT $LL31@inflate_ta
$LN32@inflate_ta:

; 243  :         if (incr != 0) {

  00426	85 d2		 test	 edx, edx
  00428	74 0b		 je	 SHORT $LN54@inflate_ta

; 244  :             huff &= incr - 1;

  0042a	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  0042d	23 f8		 and	 edi, eax

; 245  :             huff += incr;

  0042f	03 fa		 add	 edi, edx

; 246  :         }

  00431	33 c9		 xor	 ecx, ecx
  00433	eb 04		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:

; 247  :         else
; 248  :             huff = 0;

  00435	33 c9		 xor	 ecx, ecx
  00437	8b f9		 mov	 edi, ecx
$LN55@inflate_ta:

; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;
; 252  :         if (--(count[len]) == 0) {

  00439	41 8b c3	 mov	 eax, r11d
  0043c	ff c5		 inc	 ebp
  0043e	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00443	66 01 54 44 20	 add	 WORD PTR count$[rsp+rax*2], dx
  00448	75 22		 jne	 SHORT $LN56@inflate_ta

; 253  :             if (len == max) break;

  0044a	45 3b d9	 cmp	 r11d, r9d
  0044d	0f 84 ea 00 00
	00		 je	 $LN82@inflate_ta

; 254  :             len = lens[work[sym]];

  00453	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  0045b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  00463	0f b7 0c 69	 movzx	 ecx, WORD PTR [rcx+rbp*2]
  00467	44 0f b7 1c 48	 movzx	 r11d, WORD PTR [rax+rcx*2]
$LN56@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  0046c	44 8b 44 24 0c	 mov	 r8d, DWORD PTR tv1879[rsp]
  00471	8b 14 24	 mov	 edx, DWORD PTR match$1$[rsp]
  00474	45 3b d8	 cmp	 r11d, r8d
  00477	0f 86 e4 fe ff
	ff		 jbe	 $LL25@inflate_ta
  0047d	44 8b 54 24 08	 mov	 r10d, DWORD PTR mask$1$[rsp]
  00482	44 23 d7	 and	 r10d, edi
  00485	45 3b d4	 cmp	 r10d, r12d
  00488	0f 84 d3 fe ff
	ff		 je	 $LL25@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)

  0048e	45 85 ed	 test	 r13d, r13d

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  00491	4d 8d 3c b7	 lea	 r15, QWORD PTR [r15+rsi*4]

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;

  00495	41 8b db	 mov	 ebx, r11d

; 268  :             left = (int)(1 << curr);

  00498	b8 01 00 00 00	 mov	 eax, 1
  0049d	45 0f 44 e8	 cmove	 r13d, r8d
  004a1	41 2b dd	 sub	 ebx, r13d
  004a4	8b cb		 mov	 ecx, ebx
  004a6	d3 e0		 shl	 eax, cl

; 269  :             while (curr + drop < max) {

  004a8	45 3b d9	 cmp	 r11d, r9d
  004ab	73 22		 jae	 SHORT $LN81@inflate_ta

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  004ad	45 8b c3	 mov	 r8d, r11d
$LL33@inflate_ta:

; 270  :                 left -= count[curr + drop];

  004b0	41 8b c8	 mov	 ecx, r8d
  004b3	0f b7 54 4c 20	 movzx	 edx, WORD PTR count$[rsp+rcx*2]
  004b8	2b c2		 sub	 eax, edx

; 271  :                 if (left <= 0) break;

  004ba	85 c0		 test	 eax, eax
  004bc	7e 0c		 jle	 SHORT $LN174@inflate_ta

; 272  :                 curr++;

  004be	ff c3		 inc	 ebx
  004c0	41 ff c0	 inc	 r8d

; 273  :                 left <<= 1;

  004c3	03 c0		 add	 eax, eax
  004c5	45 3b c1	 cmp	 r8d, r9d
  004c8	72 e6		 jb	 SHORT $LL33@inflate_ta
$LN174@inflate_ta:
  004ca	44 8b 44 24 0c	 mov	 r8d, DWORD PTR tv1879[rsp]
$LN81@inflate_ta:

; 274  :             }
; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;

  004cf	8b cb		 mov	 ecx, ebx
  004d1	b8 01 00 00 00	 mov	 eax, 1
  004d6	d3 e0		 shl	 eax, cl
  004d8	44 03 f0	 add	 r14d, eax

; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||

  004db	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  004e2	83 f8 01	 cmp	 eax, 1
  004e5	75 09		 jne	 SHORT $LN63@inflate_ta
  004e7	41 81 fe 54 03
	00 00		 cmp	 r14d, 852		; 00000354H
  004ee	eb 0c		 jmp	 SHORT $LN185@inflate_ta
$LN63@inflate_ta:
  004f0	83 f8 02	 cmp	 eax, 2
  004f3	75 0d		 jne	 SHORT $LN61@inflate_ta
  004f5	41 81 fe 50 02
	00 00		 cmp	 r14d, 592		; 00000250H
$LN185@inflate_ta:

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;

  004fc	0f 87 9b 00 00
	00		 ja	 $LN62@inflate_ta
$LN61@inflate_ta:

; 284  :             (*table)[low].op = (unsigned char)curr;

  00502	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0050a	4a 8d 14 95 00
	00 00 00	 lea	 rdx, QWORD PTR [r10*4]
  00512	45 8b e2	 mov	 r12d, r10d
  00515	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00518	88 1c 02	 mov	 BYTE PTR [rdx+rax], bl

; 285  :             (*table)[low].bits = (unsigned char)root;

  0051b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0051e	44 88 44 02 01	 mov	 BYTE PTR [rdx+rax+1], r8b

; 286  :             (*table)[low].val = (unsigned short)(next - *table);

  00523	49 8b c7	 mov	 rax, r15
  00526	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00529	48 2b c1	 sub	 rax, rcx
  0052c	48 c1 f8 02	 sar	 rax, 2
  00530	66 89 44 11 02	 mov	 WORD PTR [rcx+rdx+2], ax

; 287  :         }
; 288  :     }

  00535	8b 14 24	 mov	 edx, DWORD PTR match$1$[rsp]
  00538	e9 24 fe ff ff	 jmp	 $LL25@inflate_ta
$LN82@inflate_ta:

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  0053d	85 ff		 test	 edi, edi
  0053f	74 1d		 je	 SHORT $LN64@inflate_ta

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */
; 295  :         here.bits = (unsigned char)(len - drop);
; 296  :         here.val = (unsigned short)0;

  00541	66 89 8c 24 c2
	00 00 00	 mov	 WORD PTR here$[rsp+2], cx

; 297  :         next[huff] = here;

  00549	8b cf		 mov	 ecx, edi
  0054b	c6 84 24 c0 00
	00 00 40	 mov	 BYTE PTR here$[rsp], 64	; 00000040H
  00553	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR here$[rsp]
  0055a	41 89 04 8f	 mov	 DWORD PTR [r15+rcx*4], eax
$LN64@inflate_ta:

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;

  0055e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00566	41 8b c6	 mov	 eax, r14d
  00569	48 c1 e0 02	 shl	 rax, 2
  0056d	48 01 01	 add	 QWORD PTR [rcx], rax

; 302  :     *bits = root;

  00570	8b 44 24 0c	 mov	 eax, DWORD PTR tv1879[rsp]
  00574	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR bits$[rsp]
  0057c	89 01		 mov	 DWORD PTR [rcx], eax

; 303  :     return 0;

  0057e	33 c0		 xor	 eax, eax
$LN183@inflate_ta:
  00580	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]
  00585	4c 8b 6c 24 78	 mov	 r13, QWORD PTR [rsp+120]
  0058a	4c 8b 7c 24 68	 mov	 r15, QWORD PTR [rsp+104]

; 304  : }

  0058f	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00596	41 5c		 pop	 r12
  00598	5f		 pop	 rdi
  00599	5e		 pop	 rsi
  0059a	5d		 pop	 rbp
  0059b	5b		 pop	 rbx
  0059c	c3		 ret	 0
$LN62@inflate_ta:

; 279  :                 (type == DISTS && used > ENOUGH_DISTS))
; 280  :                 return 1;

  0059d	b8 01 00 00 00	 mov	 eax, 1
  005a2	eb dc		 jmp	 SHORT $LN183@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  005a4	b8 ff ff ff ff	 mov	 eax, -1

; 304  : }

  005a9	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  005b0	41 5c		 pop	 r12
  005b2	5f		 pop	 rdi
  005b3	5e		 pop	 rsi
  005b4	5d		 pop	 rbp
  005b5	5b		 pop	 rbx
  005b6	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
