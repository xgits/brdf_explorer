; Listing generated by Microsoft (R) Optimizing Compiler Version 19.31.31107.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type@		; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@	; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ DB 'invalid distanc'
	DB	'e too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code@ DB 'invalid distance code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ DB 'invalid literal/le'
	DB	'ngth code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set@ DB 'invalid distances set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ DB 'invalid literal/le'
	DB	'ngths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ DB 'invalid c'
	DB	'ode -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ DB 'invalid bit length r'
	DB	'epeat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@ DB 'invalid code lengths '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ DB 'too many len'
	DB	'gth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ DB 'invalid stored bl'
	DB	'ock lengths', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateBackEnd
PUBLIC	inflateBack
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN6
	DD	imagerel $LN6+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN506
	DD	imagerel $LN506+66
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN506+66
	DD	imagerel $LN506+3749
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN506+3749
	DD	imagerel $LN506+3844
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateBackInit_ DD imagerel $LN14+87
	DD	imagerel $LN14+199
	DD	imagerel $chain$1$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN14+199
	DD	imagerel $LN14+232
	DD	imagerel $chain$3$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBackInit_ DD imagerel $LN14+232
	DD	imagerel $LN14+274
	DD	imagerel $chain$4$inflateBackInit_
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBackInit_ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 040021H
	DD	07e400H
	DD	067400H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateBackInit_ DD 040a21H
	DD	07e40aH
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN506
	DD	imagerel $LN506+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 082321H
	DD	0be423H
	DD	0c741fH
	DD	0d641bH
	DD	0e3404H
	DD	imagerel $LN506
	DD	imagerel $LN506+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016d018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File G:\1_Projects\BRDF\DisneyBRDF\zlib-1.2.12\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN14:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 dd 00 00
	00		 je	 $LN3@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 d3 00 00
	00		 jne	 $LN3@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 c8 00 00
	00		 jne	 $LN3@inflateBac

; 38   :         stream_size != (int)(sizeof(z_stream)))
; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 aa 00 00
	00		 je	 $LN5@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 a1 00 00
	00		 je	 $LN5@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 95 00 00
	00		 ja	 $LN5@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */
; 44   :     if (strm->zalloc == (alloc_func)0) {

  00053	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00057	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0005c	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00061	45 33 f6	 xor	 r14d, r14d
  00064	4c 89 71 20	 mov	 QWORD PTR [rcx+32], r14
  00068	48 85 c0	 test	 rax, rax
  0006b	75 14		 jne	 SHORT $LN10@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 49   :         strm->opaque = (voidpf)0;

  00074	4c 89 71 40	 mov	 QWORD PTR [rcx+64], r14
  00078	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  0007c	41 8b ce	 mov	 ecx, r14d
  0007f	eb 04		 jmp	 SHORT $LN6@inflateBac
$LN10@inflateBac:
  00081	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN6@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00085	4c 39 73 38	 cmp	 QWORD PTR [rbx+56], r14
  00089	75 0b		 jne	 SHORT $LN7@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  00092	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN7@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  00096	bf 01 00 00 00	 mov	 edi, 1
  0009b	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000a1	8b d7		 mov	 edx, edi
  000a3	ff d0		 call	 rax

; 59   :                                                sizeof(struct inflate_state));
; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a5	48 85 c0	 test	 rax, rax
  000a8	75 1d		 jne	 SHORT $LN8@inflateBac
  000aa	8d 47 fb	 lea	 eax, QWORD PTR [rdi-5]
$LN12@inflateBac:
  000ad	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000b2	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 70   : }

  000b7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000bc	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c5	5e		 pop	 rsi
  000c6	c3		 ret	 0
$LN8@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000c7	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = (uInt)windowBits;
; 65   :     state->wsize = 1U << windowBits;

  000cb	8b ce		 mov	 ecx, esi
  000cd	d3 e7		 shl	 edi, cl
  000cf	89 78 34	 mov	 DWORD PTR [rax+52], edi
  000d2	c7 40 1c 00 80
	00 00		 mov	 DWORD PTR [rax+28], 32768 ; 00008000H
  000d9	89 70 30	 mov	 DWORD PTR [rax+48], esi

; 66   :     state->window = window;

  000dc	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp

; 67   :     state->wnext = 0;
; 68   :     state->whave = 0;

  000e0	4c 89 70 38	 mov	 QWORD PTR [rax+56], r14

; 69   :     return Z_OK;

  000e4	33 c0		 xor	 eax, eax
  000e6	eb c5		 jmp	 SHORT $LN12@inflateBac
$LN5@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  000e8	b8 fe ff ff ff	 mov	 eax, -2

; 70   : }

  000ed	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fb	5e		 pop	 rsi
  000fc	c3		 ret	 0
$LN3@inflateBac:
  000fd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00102	b8 fa ff ff ff	 mov	 eax, -6
  00107	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0010c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00110	5e		 pop	 rsi
  00111	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\1_Projects\BRDF\DisneyBRDF\zlib-1.2.12\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 121  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 122  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 123  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\1_Projects\BRDF\DisneyBRDF\zlib-1.2.12\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 256  : {

$LN506:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b e8	 mov	 r13, r8
  00024	4c 8b e2	 mov	 r12, rdx
  00027	4c 8b d9	 mov	 r11, rcx

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 72 0e 00
	00		 je	 $LN254@inflateBac
  00033	4c 8b 79 28	 mov	 r15, QWORD PTR [rcx+40]
  00037	4d 85 ff	 test	 r15, r15
  0003a	0f 84 65 0e 00
	00		 je	 $LN254@inflateBac

; 275  :     state = (struct inflate_state FAR *)strm->state;
; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00040	33 d2		 xor	 edx, edx
  00042	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00046	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 279  :     state->mode = TYPE;

  0004a	49 c7 47 08 3f
	3f 00 00	 mov	 QWORD PTR [r15+8], 16191 ; 00003f3fH

; 280  :     state->last = 0;
; 281  :     state->whave = 0;

  00052	41 89 57 38	 mov	 DWORD PTR [r15+56], edx

; 282  :     next = strm->next_in;

  00056	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00059	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0005d	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  00061	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14
  00065	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00069	4d 85 c0	 test	 r8, r8

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  0006c	74 05		 je	 SHORT $LN343@inflateBac
  0006e	8b 59 08	 mov	 ebx, DWORD PTR [rcx+8]
  00071	eb 02		 jmp	 SHORT $LN344@inflateBac
$LN343@inflateBac:
  00073	8b da		 mov	 ebx, edx
$LN344@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00075	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00079	44 8b f2	 mov	 r14d, edx
  0007c	49 8b 7f 40	 mov	 rdi, QWORD PTR [r15+64]
  00080	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00085	45 8b 4f 34	 mov	 r9d, DWORD PTR [r15+52]
  00089	8b f2		 mov	 esi, edx
  0008b	48 89 7d c8	 mov	 QWORD PTR put$1$[rbp-120], rdi
  0008f	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  00093	83 f8 12	 cmp	 eax, 18
  00096	0f 87 d6 0d 00
	00		 ja	 $LN341@inflateBac
$LN502@inflateBac:
  0009c	48 98		 cdqe
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a5	41 ba 01 00 00
	00		 mov	 r10d, 1
  000ab	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN481@inflateBac[rcx+rax*4]
  000b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000b9	48 03 c8	 add	 rcx, rax
  000bc	ff e1		 jmp	 rcx
$LN255@inflateBac:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000be	41 83 7f 0c 00	 cmp	 DWORD PTR [r15+12], 0
  000c3	74 17		 je	 SHORT $LN12@inflateBac

; 295  :                 BYTEBITS();

  000c5	8b ce		 mov	 ecx, esi

; 296  :                 state->mode = DONE;

  000c7	41 c7 47 08 50
	3f 00 00	 mov	 DWORD PTR [r15+8], 16208 ; 00003f50H
  000cf	83 e1 07	 and	 ecx, 7
  000d2	41 d3 ee	 shr	 r14d, cl
  000d5	2b f1		 sub	 esi, ecx

; 297  :                 break;

  000d7	e9 38 0d 00 00	 jmp	 $LN499@inflateBac
$LN12@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  000dc	83 fe 03	 cmp	 esi, 3
  000df	73 40		 jae	 SHORT $LN10@inflateBac
$LL13@inflateBac:
  000e1	85 db		 test	 ebx, ebx
  000e3	75 18		 jne	 SHORT $LN18@inflateBac
  000e5	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e9	49 8b cd	 mov	 rcx, r13
  000ec	41 ff d4	 call	 r12
  000ef	8b d8		 mov	 ebx, eax
  000f1	85 c0		 test	 eax, eax
  000f3	0f 84 3c 0d 00
	00		 je	 $LN369@inflateBac
  000f9	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN18@inflateBac:
  000fd	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00101	8b ce		 mov	 ecx, esi
  00103	d3 e0		 shl	 eax, cl
  00105	49 ff c0	 inc	 r8
  00108	44 03 f0	 add	 r14d, eax
  0010b	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  0010f	ff cb		 dec	 ebx
  00111	83 c6 08	 add	 esi, 8
  00114	83 fe 03	 cmp	 esi, 3
  00117	72 c8		 jb	 SHORT $LL13@inflateBac
  00119	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0011d	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
$LN10@inflateBac:

; 300  :             state->last = BITS(1);

  00121	41 8b c6	 mov	 eax, r14d

; 301  :             DROPBITS(1);

  00124	41 d1 ee	 shr	 r14d, 1
  00127	83 e0 01	 and	 eax, 1
  0012a	41 89 47 0c	 mov	 DWORD PTR [r15+12], eax

; 302  :             switch (BITS(2)) {

  0012e	41 8b c6	 mov	 eax, r14d
  00131	83 e0 03	 and	 eax, 3
  00134	74 5e		 je	 SHORT $LN259@inflateBac
  00136	83 e8 01	 sub	 eax, 1
  00139	74 3d		 je	 SHORT $LN260@inflateBac
  0013b	83 e8 01	 sub	 eax, 1
  0013e	74 24		 je	 SHORT $LN261@inflateBac
  00140	83 f8 01	 cmp	 eax, 1
  00143	75 57		 jne	 SHORT $LN28@inflateBac

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */
; 313  :                 break;
; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;
; 318  :                 break;
; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  00145	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0014c	41 c1 ee 02	 shr	 r14d, 2
  00150	49 89 43 20	 mov	 QWORD PTR [r11+32], rax
  00154	83 c6 fd	 add	 esi, -3			; fffffffdH
  00157	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 324  :             break;

  0015f	e9 b0 0c 00 00	 jmp	 $LN499@inflateBac
$LN261@inflateBac:

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00164	41 c1 ee 02	 shr	 r14d, 2
  00168	83 c6 fd	 add	 esi, -3			; fffffffdH
  0016b	41 c7 47 08 44
	3f 00 00	 mov	 DWORD PTR [r15+8], 16196 ; 00003f44H

; 324  :             break;

  00173	e9 9c 0c 00 00	 jmp	 $LN499@inflateBac
$LN260@inflateBac:

; 307  :                 break;
; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  00178	49 8b cf	 mov	 rcx, r15
  0017b	e8 00 00 00 00	 call	 fixedtables

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  00180	41 c1 ee 02	 shr	 r14d, 2
  00184	83 c6 fd	 add	 esi, -3			; fffffffdH
  00187	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 324  :             break;

  0018f	e9 80 0c 00 00	 jmp	 $LN499@inflateBac
$LN259@inflateBac:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  00194	41 c7 47 08 41
	3f 00 00	 mov	 DWORD PTR [r15+8], 16193 ; 00003f41H
$LN28@inflateBac:

; 321  :                 state->mode = BAD;
; 322  :             }
; 323  :             DROPBITS(2);

  0019c	41 c1 ee 02	 shr	 r14d, 2
  001a0	83 c6 fd	 add	 esi, -3			; fffffffdH

; 324  :             break;

  001a3	e9 6c 0c 00 00	 jmp	 $LN499@inflateBac
$LN31@inflateBac:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  001a8	8b ce		 mov	 ecx, esi
  001aa	83 e1 07	 and	 ecx, 7
  001ad	41 d3 ee	 shr	 r14d, cl
  001b0	2b f1		 sub	 esi, ecx

; 329  :             NEEDBITS(32);

  001b2	83 fe 20	 cmp	 esi, 32			; 00000020H
  001b5	73 42		 jae	 SHORT $LN32@inflateBac
$LL35@inflateBac:
  001b7	85 db		 test	 ebx, ebx
  001b9	75 18		 jne	 SHORT $LN40@inflateBac
  001bb	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001bf	49 8b cd	 mov	 rcx, r13
  001c2	41 ff d4	 call	 r12
  001c5	8b d8		 mov	 ebx, eax
  001c7	85 c0		 test	 eax, eax
  001c9	0f 84 66 0c 00
	00		 je	 $LN369@inflateBac
  001cf	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN40@inflateBac:
  001d3	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  001d7	8b ce		 mov	 ecx, esi
  001d9	d3 e0		 shl	 eax, cl
  001db	49 ff c0	 inc	 r8
  001de	44 03 f0	 add	 r14d, eax
  001e1	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  001e5	ff cb		 dec	 ebx
  001e7	83 c6 08	 add	 esi, 8
  001ea	83 fe 20	 cmp	 esi, 32			; 00000020H
  001ed	72 c8		 jb	 SHORT $LL35@inflateBac
  001ef	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  001f3	33 d2		 xor	 edx, edx
  001f5	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
$LN32@inflateBac:

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001f9	41 8b c6	 mov	 eax, r14d
  001fc	41 0f b7 fe	 movzx	 edi, r14w
  00200	f7 d0		 not	 eax
  00202	c1 e8 10	 shr	 eax, 16
  00205	3b f8		 cmp	 edi, eax
  00207	74 1c		 je	 SHORT $LN266@inflateBac

; 331  :                 strm->msg = (char *)"invalid stored block lengths";
; 332  :                 state->mode = BAD;
; 333  :                 break;

  00209	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  0020d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  00214	49 89 43 20	 mov	 QWORD PTR [r11+32], rax
  00218	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00220	e9 ef 0b 00 00	 jmp	 $LN499@inflateBac
$LN266@inflateBac:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  00225	41 89 7f 50	 mov	 DWORD PTR [r15+80], edi

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  00229	44 8b f2	 mov	 r14d, edx
  0022c	8b f2		 mov	 esi, edx

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  0022e	85 ff		 test	 edi, edi
  00230	0f 84 9c 00 00
	00		 je	 $LN47@inflateBac
  00236	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  0023a	66 0f 1f 44 00
	00		 npad	 6
$LL46@inflateBac:

; 342  :                 copy = state->length;
; 343  :                 PULL();

  00240	85 db		 test	 ebx, ebx
  00242	75 18		 jne	 SHORT $LN48@inflateBac
  00244	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00248	49 8b cd	 mov	 rcx, r13
  0024b	41 ff d4	 call	 r12
  0024e	8b d8		 mov	 ebx, eax
  00250	85 c0		 test	 eax, eax
  00252	0f 84 dd 0b 00
	00		 je	 $LN369@inflateBac
  00258	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
$LN48@inflateBac:

; 344  :                 ROOM();

  0025c	45 85 c0	 test	 r8d, r8d
  0025f	75 2c		 jne	 SHORT $LN51@inflateBac
  00261	41 8b 4f 34	 mov	 ecx, DWORD PTR [r15+52]
  00265	44 8b c1	 mov	 r8d, ecx
  00268	49 8b 47 40	 mov	 rax, QWORD PTR [r15+64]
  0026c	89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], ecx
  0026f	48 8b d0	 mov	 rdx, rax
  00272	41 89 4f 38	 mov	 DWORD PTR [r15+56], ecx
  00276	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  0027a	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  0027e	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00281	85 c0		 test	 eax, eax
  00283	0f 85 1f 08 00
	00		 jne	 $LN372@inflateBac
  00289	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
$LN51@inflateBac:

; 345  :                 if (copy > have) copy = have;
; 346  :                 if (copy > left) copy = left;
; 347  :                 zmemcpy(put, next, copy);

  0028d	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00291	3b fb		 cmp	 edi, ebx
  00293	41 8b c0	 mov	 eax, r8d
  00296	8b cb		 mov	 ecx, ebx
  00298	0f 46 cf	 cmovbe	 ecx, edi
  0029b	41 3b c8	 cmp	 ecx, r8d
  0029e	0f 46 c1	 cmovbe	 eax, ecx
  002a1	48 8b 4d c8	 mov	 rcx, QWORD PTR put$1$[rbp-120]
  002a5	44 8b c0	 mov	 r8d, eax
  002a8	8b f8		 mov	 edi, eax
  002aa	e8 00 00 00 00	 call	 memcpy

; 348  :                 have -= copy;
; 349  :                 next += copy;
; 350  :                 left -= copy;

  002af	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  002b3	2b df		 sub	 ebx, edi
  002b5	48 01 7d c0	 add	 QWORD PTR next$[rbp-120], rdi
  002b9	44 2b c7	 sub	 r8d, edi

; 351  :                 put += copy;

  002bc	48 01 7d c8	 add	 QWORD PTR put$1$[rbp-120], rdi

; 352  :                 state->length -= copy;

  002c0	41 29 7f 50	 sub	 DWORD PTR [r15+80], edi
  002c4	41 8b 7f 50	 mov	 edi, DWORD PTR [r15+80]
  002c8	44 89 45 b8	 mov	 DWORD PTR left$1$[rbp-120], r8d
  002cc	0f 85 6e ff ff
	ff		 jne	 $LL46@inflateBac
$LN47@inflateBac:

; 353  :             }
; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;
; 356  :             break;

  002d2	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  002d6	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH
  002de	e9 29 0b 00 00	 jmp	 $LN489@inflateBac
$LN56@inflateBac:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  002e3	83 fe 0e	 cmp	 esi, 14
  002e6	73 40		 jae	 SHORT $LN54@inflateBac
$LL57@inflateBac:
  002e8	85 db		 test	 ebx, ebx
  002ea	75 18		 jne	 SHORT $LN62@inflateBac
  002ec	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002f0	49 8b cd	 mov	 rcx, r13
  002f3	41 ff d4	 call	 r12
  002f6	8b d8		 mov	 ebx, eax
  002f8	85 c0		 test	 eax, eax
  002fa	0f 84 35 0b 00
	00		 je	 $LN369@inflateBac
  00300	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN62@inflateBac:
  00304	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00308	8b ce		 mov	 ecx, esi
  0030a	d3 e0		 shl	 eax, cl
  0030c	49 ff c0	 inc	 r8
  0030f	44 03 f0	 add	 r14d, eax
  00312	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00316	ff cb		 dec	 ebx
  00318	83 c6 08	 add	 esi, 8
  0031b	83 fe 0e	 cmp	 esi, 14
  0031e	72 c8		 jb	 SHORT $LL57@inflateBac
  00320	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00324	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
$LN54@inflateBac:

; 361  :             state->nlen = BITS(5) + 257;

  00328	41 8b ce	 mov	 ecx, r14d

; 362  :             DROPBITS(5);
; 363  :             state->ndist = BITS(5) + 1;
; 364  :             DROPBITS(5);
; 365  :             state->ncode = BITS(4) + 4;
; 366  :             DROPBITS(4);

  0032b	83 c6 f2	 add	 esi, -14		; fffffff2H
  0032e	41 c1 ee 05	 shr	 r14d, 5
  00332	83 e1 1f	 and	 ecx, 31
  00335	41 8b d6	 mov	 edx, r14d
  00338	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  0033e	41 c1 ee 05	 shr	 r14d, 5
  00342	83 e2 1f	 and	 edx, 31
  00345	45 8b c6	 mov	 r8d, r14d
  00348	41 89 4f 7c	 mov	 DWORD PTR [r15+124], ecx
  0034c	41 83 e0 0f	 and	 r8d, 15
  00350	41 c1 ee 04	 shr	 r14d, 4
  00354	41 83 c0 04	 add	 r8d, 4
  00358	ff c2		 inc	 edx
  0035a	41 89 97 80 00
	00 00		 mov	 DWORD PTR [r15+128], edx
  00361	45 89 47 78	 mov	 DWORD PTR [r15+120], r8d

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  00365	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  0036b	0f 87 9d 05 00
	00		 ja	 $LN277@inflateBac
  00371	83 fa 1e	 cmp	 edx, 30
  00374	0f 87 94 05 00
	00		 ja	 $LN277@inflateBac

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  0037a	33 c9		 xor	 ecx, ecx

; 378  :             while (state->have < state->ncode) {

  0037c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00383	41 89 8f 84 00
	00 00		 mov	 DWORD PTR [r15+132], ecx
  0038a	8b c1		 mov	 eax, ecx
  0038c	45 85 c0	 test	 r8d, r8d
  0038f	0f 84 8a 00 00
	00		 je	 $LN472@inflateBac
$LL74@inflateBac:

; 379  :                 NEEDBITS(3);

  00395	83 fe 03	 cmp	 esi, 3
  00398	73 44		 jae	 SHORT $LN76@inflateBac
  0039a	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  0039e	66 90		 npad	 2
$LL79@inflateBac:
  003a0	85 db		 test	 ebx, ebx
  003a2	75 18		 jne	 SHORT $LN84@inflateBac
  003a4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  003a8	49 8b cd	 mov	 rcx, r13
  003ab	41 ff d4	 call	 r12
  003ae	8b d8		 mov	 ebx, eax
  003b0	85 c0		 test	 eax, eax
  003b2	0f 84 7d 0a 00
	00		 je	 $LN369@inflateBac
  003b8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN84@inflateBac:
  003bc	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003bf	8b ce		 mov	 ecx, esi
  003c1	d3 e0		 shl	 eax, cl
  003c3	48 ff c2	 inc	 rdx
  003c6	44 03 f0	 add	 r14d, eax
  003c9	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003cd	ff cb		 dec	 ebx
  003cf	83 c6 08	 add	 esi, 8
  003d2	83 fe 03	 cmp	 esi, 3
  003d5	72 c9		 jb	 SHORT $LL79@inflateBac
  003d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LN76@inflateBac:

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003de	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  003e5	41 0f b7 ce	 movzx	 ecx, r14w
  003e9	66 83 e1 07	 and	 cx, 7

; 381  :                 DROPBITS(3);

  003ed	41 c1 ee 03	 shr	 r14d, 3
  003f1	83 c6 fd	 add	 esi, -3			; fffffffdH
  003f4	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  003fc	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  00405	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  0040c	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00413	41 3b 47 78	 cmp	 eax, DWORD PTR [r15+120]
  00417	0f 82 78 ff ff
	ff		 jb	 $LL74@inflateBac
  0041d	33 c9		 xor	 ecx, ecx
$LN472@inflateBac:

; 382  :             }
; 383  :             while (state->have < 19)

  0041f	83 f8 13	 cmp	 eax, 19
  00422	73 26		 jae	 SHORT $LN91@inflateBac
$LL90@inflateBac:

; 384  :                 state->lens[order[state->have++]] = 0;

  00424	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  0042c	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  00435	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  0043c	ff c0		 inc	 eax
  0043e	41 89 87 84 00
	00 00		 mov	 DWORD PTR [r15+132], eax
  00445	83 f8 13	 cmp	 eax, 19
  00448	72 da		 jb	 SHORT $LL90@inflateBac
$LN91@inflateBac:

; 385  :             state->next = state->codes;

  0044a	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]

; 386  :             state->lencode = (code const FAR *)(state->next);
; 387  :             state->lenbits = 7;

  00451	41 c7 47 70 07
	00 00 00	 mov	 DWORD PTR [r15+112], 7

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00459	49 8d 97 10 03
	00 00		 lea	 rdx, QWORD PTR [r15+784]
  00460	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  00467	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0046c	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  00473	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  00477	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  0047e	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  00482	41 b8 13 00 00
	00		 mov	 r8d, 19
  00488	33 c9		 xor	 ecx, ecx
  0048a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0048f	e8 00 00 00 00	 call	 inflate_table

; 389  :                                 &(state->lenbits), state->work);
; 390  :             if (ret) {

  00494	85 c0		 test	 eax, eax
  00496	74 1c		 je	 SHORT $LN280@inflateBac

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  00498	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
  0049c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  004a3	49 89 43 20	 mov	 QWORD PTR [r11+32], rax

; 392  :                 state->mode = BAD;

  004a7	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 393  :                 break;

  004af	e9 5c 09 00 00	 jmp	 $LN500@inflateBac
$LN280@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  004b4	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  004bb	41 c7 87 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [r15+132], 0
  004c6	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  004ca	0f 84 93 02 00
	00		 je	 $LN497@inflateBac
  004d0	49 8d 7f 70	 lea	 rdi, QWORD PTR [r15+112]
  004d4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL92@inflateBac:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  004e0	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  004e2	b8 01 00 00 00	 mov	 eax, 1

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  004e7	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  004eb	d3 e0		 shl	 eax, cl
  004ed	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004f0	41 8b c6	 mov	 eax, r14d
  004f3	48 23 c8	 and	 rcx, rax
  004f6	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  004fa	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  004fd	8b d0		 mov	 edx, eax
  004ff	c1 ea 08	 shr	 edx, 8
  00502	44 8b c8	 mov	 r9d, eax
  00505	0f b6 ca	 movzx	 ecx, dl
  00508	41 c1 e9 10	 shr	 r9d, 16
  0050c	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  0050f	3b ce		 cmp	 ecx, esi
  00511	76 62		 jbe	 SHORT $LN375@inflateBac
$LL94@inflateBac:

; 403  :                     PULLBYTE();

  00513	85 db		 test	 ebx, ebx
  00515	75 18		 jne	 SHORT $LN100@inflateBac
  00517	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0051b	49 8b cd	 mov	 rcx, r13
  0051e	41 ff d4	 call	 r12
  00521	8b d8		 mov	 ebx, eax
  00523	85 c0		 test	 eax, eax
  00525	0f 84 0a 09 00
	00		 je	 $LN369@inflateBac
  0052b	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN100@inflateBac:
  0052f	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00533	8b ce		 mov	 ecx, esi
  00535	d3 e0		 shl	 eax, cl
  00537	49 ff c0	 inc	 r8
  0053a	44 03 f0	 add	 r14d, eax
  0053d	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00541	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00543	b8 01 00 00 00	 mov	 eax, 1
  00548	d3 e0		 shl	 eax, cl
  0054a	ff cb		 dec	 ebx
  0054c	41 8b d6	 mov	 edx, r14d
  0054f	83 c6 08	 add	 esi, 8
  00552	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00555	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00559	48 23 ca	 and	 rcx, rdx
  0055c	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0055f	8b d0		 mov	 edx, eax
  00561	c1 ea 08	 shr	 edx, 8
  00564	44 8b c8	 mov	 r9d, eax
  00567	0f b6 ca	 movzx	 ecx, dl
  0056a	41 c1 e9 10	 shr	 r9d, 16
  0056e	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00571	3b ce		 cmp	 ecx, esi
  00573	77 9e		 ja	 SHORT $LL94@inflateBac
$LN375@inflateBac:

; 404  :                 }
; 405  :                 if (here.val < 16) {

  00575	66 41 83 f9 10	 cmp	 r9w, 16
  0057a	73 35		 jae	 SHORT $LN284@inflateBac

; 406  :                     DROPBITS(here.bits);

  0057c	8b ca		 mov	 ecx, edx
  0057e	41 d3 ee	 shr	 r14d, cl
  00581	8b c8		 mov	 ecx, eax
  00583	c1 e9 08	 shr	 ecx, 8
  00586	0f b6 c9	 movzx	 ecx, cl
  00589	2b f1		 sub	 esi, ecx

; 407  :                     state->lens[state->have++] = here.val;

  0058b	c1 e8 10	 shr	 eax, 16
  0058e	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  00595	66 41 89 84 4f
	90 00 00 00	 mov	 WORD PTR [r15+rcx*2+144], ax
  0059e	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  005a5	45 8b 87 84 00
	00 00		 mov	 r8d, DWORD PTR [r15+132]

; 408  :                 }

  005ac	e9 9a 01 00 00	 jmp	 $LN406@inflateBac
$LN284@inflateBac:

; 409  :                 else {
; 410  :                     if (here.val == 16) {

  005b1	0f b6 fa	 movzx	 edi, dl
  005b4	75 7d		 jne	 SHORT $LN286@inflateBac

; 411  :                         NEEDBITS(here.bits + 2);

  005b6	c1 e8 08	 shr	 eax, 8
  005b9	83 c7 02	 add	 edi, 2
  005bc	44 0f b6 e0	 movzx	 r12d, al
  005c0	3b f7		 cmp	 esi, edi
  005c2	73 37		 jae	 SHORT $LN106@inflateBac
$LL109@inflateBac:
  005c4	85 db		 test	 ebx, ebx
  005c6	75 18		 jne	 SHORT $LN114@inflateBac
  005c8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  005cc	49 8b cd	 mov	 rcx, r13
  005cf	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  005d2	8b d8		 mov	 ebx, eax
  005d4	85 c0		 test	 eax, eax
  005d6	0f 84 59 08 00
	00		 je	 $LN369@inflateBac
  005dc	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN114@inflateBac:
  005e0	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  005e4	8b ce		 mov	 ecx, esi
  005e6	d3 e0		 shl	 eax, cl
  005e8	49 ff c0	 inc	 r8
  005eb	44 03 f0	 add	 r14d, eax
  005ee	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  005f2	ff cb		 dec	 ebx
  005f4	83 c6 08	 add	 esi, 8
  005f7	3b f7		 cmp	 esi, edi
  005f9	72 c9		 jb	 SHORT $LL109@inflateBac
$LN106@inflateBac:

; 412  :                         DROPBITS(here.bits);
; 413  :                         if (state->have == 0) {

  005fb	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00602	41 8b cc	 mov	 ecx, r12d
  00605	41 d3 ee	 shr	 r14d, cl
  00608	41 2b f4	 sub	 esi, r12d
  0060b	85 c0		 test	 eax, eax
  0060d	0f 84 85 01 00
	00		 je	 $LN380@inflateBac

; 414  :                             strm->msg = (char *)"invalid bit length repeat";
; 415  :                             state->mode = BAD;
; 416  :                             break;
; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);
; 419  :                         copy = 3 + BITS(2);

  00613	41 8b d6	 mov	 edx, r14d

; 420  :                         DROPBITS(2);

  00616	83 c6 fe	 add	 esi, -2			; fffffffeH
  00619	83 e2 03	 and	 edx, 3
  0061c	41 c1 ee 02	 shr	 r14d, 2
  00620	83 c2 03	 add	 edx, 3
  00623	ff c8		 dec	 eax
  00625	45 0f b7 8c 47
	90 00 00 00	 movzx	 r9d, WORD PTR [r15+rax*2+144]

; 421  :                     }

  0062e	e9 cf 00 00 00	 jmp	 $LN155@inflateBac
$LN286@inflateBac:

; 422  :                     else if (here.val == 17) {

  00633	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR here$[rbp-119]
  00638	66 41 83 f9 11	 cmp	 r9w, 17
  0063d	75 62		 jne	 SHORT $LN142@inflateBac

; 423  :                         NEEDBITS(here.bits + 3);

  0063f	83 c7 03	 add	 edi, 3
  00642	3b f7		 cmp	 esi, edi
  00644	73 37		 jae	 SHORT $LN123@inflateBac
$LL126@inflateBac:
  00646	85 db		 test	 ebx, ebx
  00648	75 18		 jne	 SHORT $LN131@inflateBac
  0064a	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0064e	49 8b cd	 mov	 rcx, r13
  00651	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00654	8b d8		 mov	 ebx, eax
  00656	85 c0		 test	 eax, eax
  00658	0f 84 d7 07 00
	00		 je	 $LN369@inflateBac
  0065e	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN131@inflateBac:
  00662	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00666	8b ce		 mov	 ecx, esi
  00668	d3 e0		 shl	 eax, cl
  0066a	49 ff c0	 inc	 r8
  0066d	44 03 f0	 add	 r14d, eax
  00670	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00674	ff cb		 dec	 ebx
  00676	83 c6 08	 add	 esi, 8
  00679	3b f7		 cmp	 esi, edi
  0067b	72 c9		 jb	 SHORT $LL126@inflateBac
$LN123@inflateBac:

; 424  :                         DROPBITS(here.bits);
; 425  :                         len = 0;
; 426  :                         copy = 3 + BITS(3);
; 427  :                         DROPBITS(3);

  0067d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00682	41 8b cc	 mov	 ecx, r12d
  00685	41 d3 ee	 shr	 r14d, cl
  00688	41 2b c4	 sub	 eax, r12d
  0068b	41 8b d6	 mov	 edx, r14d
  0068e	03 f0		 add	 esi, eax
  00690	83 e2 07	 and	 edx, 7
  00693	41 c1 ee 03	 shr	 r14d, 3
  00697	83 c2 03	 add	 edx, 3
  0069a	33 c0		 xor	 eax, eax
  0069c	44 8b c8	 mov	 r9d, eax

; 428  :                     }

  0069f	eb 61		 jmp	 SHORT $LN155@inflateBac
$LN142@inflateBac:

; 429  :                     else {
; 430  :                         NEEDBITS(here.bits + 7);

  006a1	83 c7 07	 add	 edi, 7
  006a4	3b f7		 cmp	 esi, edi
  006a6	73 37		 jae	 SHORT $LN140@inflateBac
$LL143@inflateBac:
  006a8	85 db		 test	 ebx, ebx
  006aa	75 18		 jne	 SHORT $LN148@inflateBac
  006ac	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  006b0	49 8b cd	 mov	 rcx, r13
  006b3	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  006b6	8b d8		 mov	 ebx, eax
  006b8	85 c0		 test	 eax, eax
  006ba	0f 84 75 07 00
	00		 je	 $LN369@inflateBac
  006c0	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN148@inflateBac:
  006c4	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  006c8	8b ce		 mov	 ecx, esi
  006ca	d3 e0		 shl	 eax, cl
  006cc	49 ff c0	 inc	 r8
  006cf	44 03 f0	 add	 r14d, eax
  006d2	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  006d6	ff cb		 dec	 ebx
  006d8	83 c6 08	 add	 esi, 8
  006db	3b f7		 cmp	 esi, edi
  006dd	72 c9		 jb	 SHORT $LL143@inflateBac
$LN140@inflateBac:

; 431  :                         DROPBITS(here.bits);
; 432  :                         len = 0;
; 433  :                         copy = 11 + BITS(7);
; 434  :                         DROPBITS(7);

  006df	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  006e4	41 8b cc	 mov	 ecx, r12d
  006e7	41 d3 ee	 shr	 r14d, cl
  006ea	41 2b c4	 sub	 eax, r12d
  006ed	41 8b d6	 mov	 edx, r14d
  006f0	03 f0		 add	 esi, eax
  006f2	83 e2 7f	 and	 edx, 127		; 0000007fH
  006f5	41 c1 ee 07	 shr	 r14d, 7
  006f9	83 c2 0b	 add	 edx, 11
  006fc	33 c0		 xor	 eax, eax
  006fe	44 0f b7 c8	 movzx	 r9d, ax
$LN155@inflateBac:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  00702	45 8b 87 84 00
	00 00		 mov	 r8d, DWORD PTR [r15+132]
  00709	41 8b 8f 80 00
	00 00		 mov	 ecx, DWORD PTR [r15+128]
  00710	41 03 4f 7c	 add	 ecx, DWORD PTR [r15+124]
  00714	41 8d 04 10	 lea	 eax, DWORD PTR [r8+rdx]
  00718	3b c1		 cmp	 eax, ecx
  0071a	77 7c		 ja	 SHORT $LN380@inflateBac
  0071c	0f 1f 40 00	 npad	 4
$LL157@inflateBac:

; 437  :                         strm->msg = (char *)"invalid bit length repeat";
; 438  :                         state->mode = BAD;
; 439  :                         break;
; 440  :                     }
; 441  :                     while (copy--)
; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00720	41 8b c0	 mov	 eax, r8d
  00723	66 45 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], r9w
  0072c	45 8b 87 84 00
	00 00		 mov	 r8d, DWORD PTR [r15+132]
  00733	45 8d 40 01	 lea	 r8d, DWORD PTR [r8+1]
  00737	45 89 87 84 00
	00 00		 mov	 DWORD PTR [r15+132], r8d
  0073e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00741	75 dd		 jne	 SHORT $LL157@inflateBac

; 403  :                     PULLBYTE();

  00743	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00747	49 8d 7f 70	 lea	 rdi, QWORD PTR [r15+112]
$LN406@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;
; 399  :             while (state->have < state->nlen + state->ndist) {

  0074b	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  00752	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  00756	44 3b c0	 cmp	 r8d, eax
  00759	0f 82 81 fd ff
	ff		 jb	 $LL92@inflateBac
  0075f	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
$LN497@inflateBac:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00763	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
$LN93@inflateBac:
  00767	41 81 7f 08 51
	3f 00 00	 cmp	 DWORD PTR [r15+8], 16209 ; 00003f51H
  0076f	0f 84 97 06 00
	00		 je	 $LN489@inflateBac

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  00775	66 41 83 bf 90
	02 00 00 00	 cmp	 WORD PTR [r15+656], 0
  0077e	75 35		 jne	 SHORT $LN299@inflateBac

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00780	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00787	49 89 43 20	 mov	 QWORD PTR [r11+32], rax

; 452  :                 state->mode = BAD;

  0078b	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 453  :                 break;

  00793	e9 78 06 00 00	 jmp	 $LN500@inflateBac
$LN380@inflateBac:

; 443  :                 }
; 444  :             }
; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00798	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
  0079c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  007a3	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  007a7	49 89 43 20	 mov	 QWORD PTR [r11+32], rax
  007ab	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  007b3	eb b2		 jmp	 SHORT $LN93@inflateBac
$LN299@inflateBac:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;
; 460  :             state->lencode = (code const FAR *)(state->next);
; 461  :             state->lenbits = 9;
; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  007b5	45 8b 47 7c	 mov	 r8d, DWORD PTR [r15+124]
  007b9	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]
  007c0	49 8d 8f 10 03
	00 00		 lea	 rcx, QWORD PTR [r15+784]
  007c7	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  007ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007d3	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  007da	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  007de	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  007e5	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  007e9	b9 01 00 00 00	 mov	 ecx, 1
  007ee	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  007f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007f9	e8 00 00 00 00	 call	 inflate_table

; 463  :                                 &(state->lenbits), state->work);
; 464  :             if (ret) {

  007fe	85 c0		 test	 eax, eax
  00800	74 1c		 je	 SHORT $LN300@inflateBac

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  00802	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
  00806	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  0080d	49 89 43 20	 mov	 QWORD PTR [r11+32], rax

; 466  :                 state->mode = BAD;

  00811	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 467  :                 break;

  00819	e9 f2 05 00 00	 jmp	 $LN500@inflateBac
$LN300@inflateBac:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  0081e	49 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [r15+136]

; 470  :             state->distbits = 6;

  00825	49 8d 4f 74	 lea	 rcx, QWORD PTR [r15+116]

; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00829	45 8b 87 80 00
	00 00		 mov	 r8d, DWORD PTR [r15+128]
  00830	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  00837	49 89 47 68	 mov	 QWORD PTR [r15+104], rax
  0083b	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  0083f	48 83 c0 48	 add	 rax, 72			; 00000048H
  00843	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00849	49 8d 14 47	 lea	 rdx, QWORD PTR [r15+rax*2]
  0084d	49 8d 87 10 03
	00 00		 lea	 rax, QWORD PTR [r15+784]
  00854	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00859	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0085e	b9 02 00 00 00	 mov	 ecx, 2
  00863	e8 00 00 00 00	 call	 inflate_table

; 472  :                             &(state->next), &(state->distbits), state->work);
; 473  :             if (ret) {

  00868	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
  0086c	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00870	85 c0		 test	 eax, eax
  00872	74 18		 je	 SHORT $LN301@inflateBac

; 474  :                 strm->msg = (char *)"invalid distances set";

  00874	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  0087b	49 89 43 20	 mov	 QWORD PTR [r11+32], rax

; 475  :                 state->mode = BAD;

  0087f	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 476  :                 break;

  00887	e9 88 05 00 00	 jmp	 $LN499@inflateBac
$LN301@inflateBac:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  0088c	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00890	41 ba 01 00 00
	00		 mov	 r10d, 1
  00896	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H
  0089e	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN302@inflateBac:

; 480  :                 /* fallthrough */
; 481  : 
; 482  :         case LEN:
; 483  :             /* use inflate_fast() if we have enough input and output */
; 484  :             if (have >= 6 && left >= 258) {

  008a2	83 fb 06	 cmp	 ebx, 6
  008a5	72 7f		 jb	 SHORT $LN303@inflateBac
  008a7	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  008ae	72 76		 jb	 SHORT $LN303@inflateBac

; 485  :                 RESTORE();

  008b0	49 89 7b 10	 mov	 QWORD PTR [r11+16], rdi
  008b4	45 89 4b 18	 mov	 DWORD PTR [r11+24], r9d
  008b8	4d 89 03	 mov	 QWORD PTR [r11], r8
  008bb	41 89 5b 08	 mov	 DWORD PTR [r11+8], ebx

; 486  :                 if (state->whave < state->wsize)

  008bf	41 8b 57 34	 mov	 edx, DWORD PTR [r15+52]
  008c3	45 89 77 48	 mov	 DWORD PTR [r15+72], r14d
  008c7	41 89 77 4c	 mov	 DWORD PTR [r15+76], esi
  008cb	41 39 57 38	 cmp	 DWORD PTR [r15+56], edx
  008cf	73 09		 jae	 SHORT $LN304@inflateBac

; 487  :                     state->whave = state->wsize - left;

  008d1	8b c2		 mov	 eax, edx
  008d3	41 2b c1	 sub	 eax, r9d
  008d6	41 89 47 38	 mov	 DWORD PTR [r15+56], eax
$LN304@inflateBac:

; 488  :                 inflate_fast(strm, state->wsize);

  008da	49 8b cb	 mov	 rcx, r11
  008dd	e8 00 00 00 00	 call	 inflate_fast

; 489  :                 LOAD();

  008e2	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
  008e6	4d 8b 03	 mov	 r8, QWORD PTR [r11]
  008e9	49 8b 7b 10	 mov	 rdi, QWORD PTR [r11+16]
  008ed	45 8b 4b 18	 mov	 r9d, DWORD PTR [r11+24]
  008f1	41 8b 5b 08	 mov	 ebx, DWORD PTR [r11+8]
  008f5	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  008f9	45 8b 77 48	 mov	 r14d, DWORD PTR [r15+72]
  008fd	41 8b 77 4c	 mov	 esi, DWORD PTR [r15+76]
  00901	48 89 7d c8	 mov	 QWORD PTR put$1$[rbp-120], rdi
  00905	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d

; 490  :                 break;

  00909	e9 0a 05 00 00	 jmp	 $LN393@inflateBac
$LN277@inflateBac:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  0090e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00915	49 89 43 20	 mov	 QWORD PTR [r11+32], rax

; 370  :                 state->mode = BAD;

  00919	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 371  :                 break;

  00921	e9 ee 04 00 00	 jmp	 $LN499@inflateBac
$LN303@inflateBac:

; 491  :             }
; 492  : 
; 493  :             /* get a literal, length, or end-of-block code */
; 494  :             for (;;) {
; 495  :                 here = state->lencode[BITS(state->lenbits)];

  00926	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  0092a	41 8b c2	 mov	 eax, r10d
  0092d	4d 8b 4f 60	 mov	 r9, QWORD PTR [r15+96]
  00931	d3 e0		 shl	 eax, cl
  00933	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00936	41 8b c6	 mov	 eax, r14d
  00939	48 23 c8	 and	 rcx, rax
  0093c	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  00940	8b c8		 mov	 ecx, eax
  00942	c1 e9 08	 shr	 ecx, 8
  00945	0f b6 c9	 movzx	 ecx, cl

; 496  :                 if ((unsigned)(here.bits) <= bits) break;

  00948	3b ce		 cmp	 ecx, esi
  0094a	76 62		 jbe	 SHORT $LN382@inflateBac
  0094c	0f 1f 40 00	 npad	 4
$LL165@inflateBac:

; 497  :                 PULLBYTE();

  00950	85 db		 test	 ebx, ebx
  00952	75 1e		 jne	 SHORT $LN171@inflateBac
  00954	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00958	49 8b cd	 mov	 rcx, r13
  0095b	41 ff d4	 call	 r12
  0095e	8b d8		 mov	 ebx, eax
  00960	85 c0		 test	 eax, eax
  00962	0f 84 cd 04 00
	00		 je	 $LN369@inflateBac
  00968	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  0096c	41 ba 01 00 00
	00		 mov	 r10d, 1
$LN171@inflateBac:
  00972	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00976	8b ce		 mov	 ecx, esi
  00978	d3 e0		 shl	 eax, cl
  0097a	49 ff c0	 inc	 r8
  0097d	44 03 f0	 add	 r14d, eax
  00980	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00984	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  00988	41 8b c2	 mov	 eax, r10d
  0098b	4d 8b 4f 60	 mov	 r9, QWORD PTR [r15+96]
  0098f	ff cb		 dec	 ebx
  00991	d3 e0		 shl	 eax, cl
  00993	83 c6 08	 add	 esi, 8
  00996	ff c8		 dec	 eax
  00998	41 8b d6	 mov	 edx, r14d
  0099b	48 23 c2	 and	 rax, rdx
  0099e	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  009a2	8b c8		 mov	 ecx, eax
  009a4	c1 e9 08	 shr	 ecx, 8
  009a7	0f b6 c9	 movzx	 ecx, cl
  009aa	3b ce		 cmp	 ecx, esi
  009ac	77 a2		 ja	 SHORT $LL165@inflateBac
$LN382@inflateBac:

; 498  :             }
; 499  :             if (here.op && (here.op & 0xf0) == 0) {

  009ae	84 c0		 test	 al, al
  009b0	0f 84 b2 00 00
	00		 je	 $LN184@inflateBac
  009b6	a8 f0		 test	 al, 240			; 000000f0H
  009b8	0f 85 aa 00 00
	00		 jne	 $LN184@inflateBac

; 500  :                 last = here;

  009be	8b c8		 mov	 ecx, eax

; 501  :                 for (;;) {
; 502  :                     here = state->lencode[last.val +

  009c0	44 8b e0	 mov	 r12d, eax
  009c3	c1 e9 08	 shr	 ecx, 8
  009c6	45 8b ea	 mov	 r13d, r10d
  009c9	0f b6 f9	 movzx	 edi, cl
  009cc	0f b6 c8	 movzx	 ecx, al
  009cf	03 cf		 add	 ecx, edi
  009d1	41 c1 ec 10	 shr	 r12d, 16
  009d5	41 d3 e5	 shl	 r13d, cl
  009d8	8b cf		 mov	 ecx, edi
  009da	41 ff cd	 dec	 r13d
  009dd	41 8b c5	 mov	 eax, r13d
  009e0	41 23 c6	 and	 eax, r14d
  009e3	d3 e8		 shr	 eax, cl
  009e5	41 03 c4	 add	 eax, r12d
  009e8	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  009ec	8b c8		 mov	 ecx, eax
  009ee	c1 e9 08	 shr	 ecx, 8

; 503  :                             (BITS(last.bits + last.op) >> last.bits)];
; 504  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  009f1	0f b6 d1	 movzx	 edx, cl
  009f4	03 d7		 add	 edx, edi
  009f6	3b d6		 cmp	 edx, esi
  009f8	76 63		 jbe	 SHORT $LN185@inflateBac
  009fa	66 0f 1f 44 00
	00		 npad	 6
$LL174@inflateBac:

; 505  :                     PULLBYTE();

  00a00	85 db		 test	 ebx, ebx
  00a02	75 19		 jne	 SHORT $LN180@inflateBac
  00a04	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00a08	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00a0c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00a0f	8b d8		 mov	 ebx, eax
  00a11	85 c0		 test	 eax, eax
  00a13	0f 84 1c 04 00
	00		 je	 $LN369@inflateBac
  00a19	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN180@inflateBac:
  00a1d	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00a21	8b ce		 mov	 ecx, esi
  00a23	d3 e0		 shl	 eax, cl
  00a25	49 ff c0	 inc	 r8
  00a28	44 03 f0	 add	 r14d, eax
  00a2b	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00a2f	41 8b c6	 mov	 eax, r14d
  00a32	8b cf		 mov	 ecx, edi
  00a34	41 23 c5	 and	 eax, r13d
  00a37	ff cb		 dec	 ebx
  00a39	d3 e8		 shr	 eax, cl
  00a3b	83 c6 08	 add	 esi, 8
  00a3e	41 8d 0c 04	 lea	 ecx, DWORD PTR [r12+rax]
  00a42	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00a46	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00a49	8b c8		 mov	 ecx, eax
  00a4b	c1 e9 08	 shr	 ecx, 8
  00a4e	0f b6 d1	 movzx	 edx, cl
  00a51	03 d7		 add	 edx, edi
  00a53	3b d6		 cmp	 edx, esi
  00a55	77 a9		 ja	 SHORT $LL174@inflateBac
  00a57	41 ba 01 00 00
	00		 mov	 r10d, 1
$LN185@inflateBac:
  00a5d	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]

; 506  :                 }
; 507  :                 DROPBITS(last.bits);

  00a61	8b cf		 mov	 ecx, edi
  00a63	41 d3 ee	 shr	 r14d, cl
  00a66	2b f7		 sub	 esi, edi
$LN184@inflateBac:

; 508  :             }
; 509  :             DROPBITS(here.bits);

  00a68	8b c8		 mov	 ecx, eax
  00a6a	c1 e9 08	 shr	 ecx, 8
  00a6d	0f b6 c9	 movzx	 ecx, cl
  00a70	41 d3 ee	 shr	 r14d, cl
  00a73	2b f1		 sub	 esi, ecx

; 510  :             state->length = (unsigned)here.val;

  00a75	8b c8		 mov	 ecx, eax
  00a77	c1 e9 10	 shr	 ecx, 16
  00a7a	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 511  : 
; 512  :             /* process literal */
; 513  :             if (here.op == 0) {

  00a7e	84 c0		 test	 al, al
  00a80	75 62		 jne	 SHORT $LN312@inflateBac

; 514  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 515  :                         "inflate:         literal '%c'\n" :
; 516  :                         "inflate:         literal 0x%02x\n", here.val));
; 517  :                 ROOM();

  00a82	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00a86	45 85 e4	 test	 r12d, r12d
  00a89	75 2c		 jne	 SHORT $LN495@inflateBac
  00a8b	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00a8f	45 8b c4	 mov	 r8d, r12d
  00a92	49 8b 7f 40	 mov	 rdi, QWORD PTR [r15+64]
  00a96	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00a9a	48 8b d7	 mov	 rdx, rdi
  00a9d	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00aa1	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00aa4	85 c0		 test	 eax, eax
  00aa6	74 13		 je	 SHORT $LN189@inflateBac
$LN372@inflateBac:

; 622  :             goto inf_leave;
; 623  :         }
; 624  : 
; 625  :     /* Return unused input */
; 626  :   inf_leave:
; 627  :     strm->next_in = next;

  00aa8	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  00aac	41 ba fb ff ff
	ff		 mov	 r10d, -5
  00ab2	e9 c1 03 00 00	 jmp	 $inf_leave$507
$LN495@inflateBac:

; 514  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 515  :                         "inflate:         literal '%c'\n" :
; 516  :                         "inflate:         literal 0x%02x\n", here.val));
; 517  :                 ROOM();

  00ab7	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
$LN189@inflateBac:

; 518  :                 *put++ = (unsigned char)(state->length);

  00abb	41 0f b6 47 50	 movzx	 eax, BYTE PTR [r15+80]

; 519  :                 left--;
; 520  :                 state->mode = LEN;
; 521  :                 break;

  00ac0	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
  00ac4	88 07		 mov	 BYTE PTR [rdi], al
  00ac6	48 ff c7	 inc	 rdi
  00ac9	41 ff cc	 dec	 r12d
  00acc	48 89 7d c8	 mov	 QWORD PTR put$1$[rbp-120], rdi
  00ad0	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00ad4	45 8b cc	 mov	 r9d, r12d
  00ad7	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H
  00adf	e9 30 03 00 00	 jmp	 $LN499@inflateBac
$LN312@inflateBac:

; 522  :             }
; 523  : 
; 524  :             /* process end of block */
; 525  :             if (here.op & 32) {

  00ae4	a8 20		 test	 al, 32			; 00000020H
  00ae6	74 11		 je	 SHORT $LN315@inflateBac

; 526  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 527  :                 state->mode = TYPE;
; 528  :                 break;

  00ae8	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  00aec	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH
  00af4	e9 13 03 00 00	 jmp	 $LN489@inflateBac
$LN315@inflateBac:

; 529  :             }
; 530  : 
; 531  :             /* invalid code */
; 532  :             if (here.op & 64) {

  00af9	a8 40		 test	 al, 64			; 00000040H
  00afb	74 20		 je	 SHORT $LN316@inflateBac

; 533  :                 strm->msg = (char *)"invalid literal/length code";

  00afd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
$LN504@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00b04	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
  00b08	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  00b0c	49 89 43 20	 mov	 QWORD PTR [r11+32], rax
  00b10	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00b18	e9 f3 02 00 00	 jmp	 $LN500@inflateBac
$LN316@inflateBac:

; 534  :                 state->mode = BAD;
; 535  :                 break;
; 536  :             }
; 537  : 
; 538  :             /* length code -- get extra bits, if any */
; 539  :             state->extra = (unsigned)(here.op) & 15;

  00b1d	0f b6 c8	 movzx	 ecx, al
  00b20	83 e1 0f	 and	 ecx, 15
  00b23	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 540  :             if (state->extra != 0) {

  00b27	74 5b		 je	 SHORT $LN204@inflateBac

; 541  :                 NEEDBITS(state->extra);

  00b29	3b f1		 cmp	 esi, ecx
  00b2b	73 44		 jae	 SHORT $LN192@inflateBac
  00b2d	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL195@inflateBac:
  00b31	85 db		 test	 ebx, ebx
  00b33	75 18		 jne	 SHORT $LN200@inflateBac
  00b35	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b39	49 8b cd	 mov	 rcx, r13
  00b3c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00b3f	8b d8		 mov	 ebx, eax
  00b41	85 c0		 test	 eax, eax
  00b43	0f 84 ec 02 00
	00		 je	 $LN369@inflateBac
  00b49	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN200@inflateBac:
  00b4d	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b50	8b ce		 mov	 ecx, esi
  00b52	d3 e0		 shl	 eax, cl
  00b54	48 ff c2	 inc	 rdx
  00b57	44 03 f0	 add	 r14d, eax
  00b5a	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b5e	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00b62	ff cb		 dec	 ebx
  00b64	83 c6 08	 add	 esi, 8
  00b67	3b f1		 cmp	 esi, ecx
  00b69	72 c6		 jb	 SHORT $LL195@inflateBac
  00b6b	41 ba 01 00 00
	00		 mov	 r10d, 1
$LN192@inflateBac:

; 542  :                 state->length += BITS(state->extra);

  00b71	41 8b c2	 mov	 eax, r10d
  00b74	d3 e0		 shl	 eax, cl
  00b76	ff c8		 dec	 eax
  00b78	41 23 c6	 and	 eax, r14d

; 543  :                 DROPBITS(state->extra);

  00b7b	41 d3 ee	 shr	 r14d, cl
  00b7e	41 01 47 50	 add	 DWORD PTR [r15+80], eax
  00b82	2b f1		 sub	 esi, ecx
$LN204@inflateBac:

; 544  :             }
; 545  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 546  : 
; 547  :             /* get distance code */
; 548  :             for (;;) {
; 549  :                 here = state->distcode[BITS(state->distbits)];

  00b84	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00b88	41 8b c2	 mov	 eax, r10d
  00b8b	4d 8b 4f 68	 mov	 r9, QWORD PTR [r15+104]

; 550  :                 if ((unsigned)(here.bits) <= bits) break;

  00b8f	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  00b93	d3 e0		 shl	 eax, cl
  00b95	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b98	41 8b c6	 mov	 eax, r14d
  00b9b	48 23 c8	 and	 rcx, rax
  00b9e	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  00ba2	8b c8		 mov	 ecx, eax
  00ba4	c1 e9 08	 shr	 ecx, 8
  00ba7	0f b6 c9	 movzx	 ecx, cl
  00baa	3b ce		 cmp	 ecx, esi
  00bac	76 60		 jbe	 SHORT $LN387@inflateBac
  00bae	66 90		 npad	 2
$LL206@inflateBac:

; 551  :                 PULLBYTE();

  00bb0	85 db		 test	 ebx, ebx
  00bb2	75 1e		 jne	 SHORT $LN212@inflateBac
  00bb4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00bb8	49 8b cd	 mov	 rcx, r13
  00bbb	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00bbe	8b d8		 mov	 ebx, eax
  00bc0	85 c0		 test	 eax, eax
  00bc2	0f 84 6d 02 00
	00		 je	 $LN369@inflateBac
  00bc8	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  00bcc	41 ba 01 00 00
	00		 mov	 r10d, 1
$LN212@inflateBac:
  00bd2	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00bd6	8b ce		 mov	 ecx, esi
  00bd8	d3 e0		 shl	 eax, cl
  00bda	49 ff c0	 inc	 r8
  00bdd	44 03 f0	 add	 r14d, eax
  00be0	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00be4	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00be8	41 8b c2	 mov	 eax, r10d
  00beb	4d 8b 4f 68	 mov	 r9, QWORD PTR [r15+104]
  00bef	ff cb		 dec	 ebx
  00bf1	d3 e0		 shl	 eax, cl
  00bf3	83 c6 08	 add	 esi, 8
  00bf6	ff c8		 dec	 eax
  00bf8	41 8b d6	 mov	 edx, r14d
  00bfb	48 23 c2	 and	 rax, rdx
  00bfe	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  00c02	8b c8		 mov	 ecx, eax
  00c04	c1 e9 08	 shr	 ecx, 8
  00c07	0f b6 c9	 movzx	 ecx, cl
  00c0a	3b ce		 cmp	 ecx, esi
  00c0c	77 a2		 ja	 SHORT $LL206@inflateBac
$LN387@inflateBac:

; 552  :             }
; 553  :             if ((here.op & 0xf0) == 0) {

  00c0e	a8 f0		 test	 al, 240			; 000000f0H
  00c10	0f 85 9f 00 00
	00		 jne	 $LN225@inflateBac

; 554  :                 last = here;

  00c16	8b c8		 mov	 ecx, eax

; 555  :                 for (;;) {
; 556  :                     here = state->distcode[last.val +

  00c18	44 8b e0	 mov	 r12d, eax
  00c1b	c1 e9 08	 shr	 ecx, 8
  00c1e	45 8b ea	 mov	 r13d, r10d
  00c21	0f b6 f9	 movzx	 edi, cl
  00c24	0f b6 c8	 movzx	 ecx, al
  00c27	03 cf		 add	 ecx, edi
  00c29	41 c1 ec 10	 shr	 r12d, 16
  00c2d	41 d3 e5	 shl	 r13d, cl
  00c30	8b cf		 mov	 ecx, edi
  00c32	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  00c36	41 23 c6	 and	 eax, r14d
  00c39	d3 e8		 shr	 eax, cl
  00c3b	41 03 c4	 add	 eax, r12d
  00c3e	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  00c42	8b c8		 mov	 ecx, eax
  00c44	c1 e9 08	 shr	 ecx, 8

; 557  :                             (BITS(last.bits + last.op) >> last.bits)];
; 558  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00c47	0f b6 d1	 movzx	 edx, cl
  00c4a	03 d7		 add	 edx, edi
  00c4c	3b d6		 cmp	 edx, esi
  00c4e	76 5e		 jbe	 SHORT $LN226@inflateBac
$LL215@inflateBac:

; 559  :                     PULLBYTE();

  00c50	85 db		 test	 ebx, ebx
  00c52	75 19		 jne	 SHORT $LN221@inflateBac
  00c54	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c58	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c5c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c5f	8b d8		 mov	 ebx, eax
  00c61	85 c0		 test	 eax, eax
  00c63	0f 84 cc 01 00
	00		 je	 $LN369@inflateBac
  00c69	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN221@inflateBac:
  00c6d	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00c71	8b ce		 mov	 ecx, esi
  00c73	d3 e0		 shl	 eax, cl
  00c75	49 ff c0	 inc	 r8
  00c78	44 03 f0	 add	 r14d, eax
  00c7b	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00c7f	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  00c83	8b cf		 mov	 ecx, edi
  00c85	41 23 c6	 and	 eax, r14d
  00c88	ff cb		 dec	 ebx
  00c8a	d3 e8		 shr	 eax, cl
  00c8c	83 c6 08	 add	 esi, 8
  00c8f	41 8d 0c 04	 lea	 ecx, DWORD PTR [r12+rax]
  00c93	49 8b 47 68	 mov	 rax, QWORD PTR [r15+104]
  00c97	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00c9a	8b c8		 mov	 ecx, eax
  00c9c	c1 e9 08	 shr	 ecx, 8
  00c9f	0f b6 d1	 movzx	 edx, cl
  00ca2	03 d7		 add	 edx, edi
  00ca4	3b d6		 cmp	 edx, esi
  00ca6	77 a8		 ja	 SHORT $LL215@inflateBac
  00ca8	41 ba 01 00 00
	00		 mov	 r10d, 1
$LN226@inflateBac:

; 560  :                 }
; 561  :                 DROPBITS(last.bits);

  00cae	8b cf		 mov	 ecx, edi
  00cb0	41 d3 ee	 shr	 r14d, cl
  00cb3	2b f7		 sub	 esi, edi
$LN225@inflateBac:

; 562  :             }
; 563  :             DROPBITS(here.bits);

  00cb5	8b c8		 mov	 ecx, eax
  00cb7	c1 e9 08	 shr	 ecx, 8
  00cba	0f b6 c9	 movzx	 ecx, cl
  00cbd	41 d3 ee	 shr	 r14d, cl
  00cc0	2b f1		 sub	 esi, ecx

; 564  :             if (here.op & 64) {

  00cc2	a8 40		 test	 al, 64			; 00000040H
  00cc4	74 0c		 je	 SHORT $LN327@inflateBac

; 565  :                 strm->msg = (char *)"invalid distance code";

  00cc6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 566  :                 state->mode = BAD;
; 567  :                 break;

  00ccd	e9 32 fe ff ff	 jmp	 $LN504@inflateBac
$LN327@inflateBac:

; 568  :             }
; 569  :             state->offset = (unsigned)here.val;

  00cd2	8b d0		 mov	 edx, eax

; 570  : 
; 571  :             /* get distance extra bits, if any */
; 572  :             state->extra = (unsigned)(here.op) & 15;

  00cd4	0f b6 c8	 movzx	 ecx, al
  00cd7	c1 ea 10	 shr	 edx, 16
  00cda	83 e1 0f	 and	 ecx, 15
  00cdd	41 89 57 54	 mov	 DWORD PTR [r15+84], edx
  00ce1	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 573  :             if (state->extra != 0) {

  00ce5	74 61		 je	 SHORT $LN242@inflateBac

; 574  :                 NEEDBITS(state->extra);

  00ce7	3b f1		 cmp	 esi, ecx
  00ce9	73 46		 jae	 SHORT $LN230@inflateBac
  00ceb	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00cef	90		 npad	 1
$LL233@inflateBac:
  00cf0	85 db		 test	 ebx, ebx
  00cf2	75 19		 jne	 SHORT $LN238@inflateBac
  00cf4	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00cf8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00cfc	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00cff	8b d8		 mov	 ebx, eax
  00d01	85 c0		 test	 eax, eax
  00d03	0f 84 2c 01 00
	00		 je	 $LN369@inflateBac
  00d09	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN238@inflateBac:
  00d0d	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00d10	8b ce		 mov	 ecx, esi
  00d12	d3 e0		 shl	 eax, cl
  00d14	48 ff c2	 inc	 rdx
  00d17	44 03 f0	 add	 r14d, eax
  00d1a	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00d1e	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00d22	ff cb		 dec	 ebx
  00d24	83 c6 08	 add	 esi, 8
  00d27	3b f1		 cmp	 esi, ecx
  00d29	72 c5		 jb	 SHORT $LL233@inflateBac
  00d2b	41 ba 01 00 00
	00		 mov	 r10d, 1
$LN230@inflateBac:

; 575  :                 state->offset += BITS(state->extra);

  00d31	41 8b c2	 mov	 eax, r10d
  00d34	d3 e0		 shl	 eax, cl
  00d36	ff c8		 dec	 eax
  00d38	41 23 c6	 and	 eax, r14d

; 576  :                 DROPBITS(state->extra);

  00d3b	41 d3 ee	 shr	 r14d, cl
  00d3e	41 01 47 54	 add	 DWORD PTR [r15+84], eax
  00d42	41 8b 57 54	 mov	 edx, DWORD PTR [r15+84]
  00d46	2b f1		 sub	 esi, ecx
$LN242@inflateBac:

; 577  :             }
; 578  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  00d48	41 8b 4f 34	 mov	 ecx, DWORD PTR [r15+52]
  00d4c	33 c0		 xor	 eax, eax
  00d4e	41 39 4f 38	 cmp	 DWORD PTR [r15+56], ecx
  00d52	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00d56	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  00d5a	41 0f 42 c4	 cmovb	 eax, r12d
  00d5e	2b c8		 sub	 ecx, eax
  00d60	3b d1		 cmp	 edx, ecx
  00d62	76 1f		 jbe	 SHORT $LL246@inflateBac

; 579  :                                                 left : 0)) {
; 580  :                 strm->msg = (char *)"invalid distance too far back";

  00d64	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
  00d68	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 581  :                 state->mode = BAD;
; 582  :                 break;

  00d6f	45 8b cc	 mov	 r9d, r12d
  00d72	49 89 43 20	 mov	 QWORD PTR [r11+32], rax
  00d76	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00d7e	e9 91 00 00 00	 jmp	 $LN499@inflateBac
$LL246@inflateBac:

; 583  :             }
; 584  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 585  : 
; 586  :             /* copy match from window to output */
; 587  :             do {
; 588  :                 ROOM();

  00d83	45 85 e4	 test	 r12d, r12d
  00d86	75 21		 jne	 SHORT $LN247@inflateBac
  00d88	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00d8c	45 8b c4	 mov	 r8d, r12d
  00d8f	49 8b 7f 40	 mov	 rdi, QWORD PTR [r15+64]
  00d93	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00d97	48 8b d7	 mov	 rdx, rdi
  00d9a	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00d9e	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00da1	85 c0		 test	 eax, eax
  00da3	0f 85 ff fc ff
	ff		 jne	 $LN372@inflateBac
$LN247@inflateBac:

; 589  :                 copy = state->wsize - state->offset;

  00da9	41 8b 4f 54	 mov	 ecx, DWORD PTR [r15+84]

; 590  :                 if (copy < left) {

  00dad	45 8b c4	 mov	 r8d, r12d
  00db0	41 8b 47 34	 mov	 eax, DWORD PTR [r15+52]
  00db4	2b c1		 sub	 eax, ecx
  00db6	41 3b c4	 cmp	 eax, r12d
  00db9	73 0a		 jae	 SHORT $LN334@inflateBac

; 591  :                     from = put + copy;

  00dbb	8b d0		 mov	 edx, eax
  00dbd	48 03 d7	 add	 rdx, rdi

; 592  :                     copy = left - copy;

  00dc0	44 2b c0	 sub	 r8d, eax

; 593  :                 }

  00dc3	eb 06		 jmp	 SHORT $LN335@inflateBac
$LN334@inflateBac:

; 594  :                 else {
; 595  :                     from = put - state->offset;

  00dc5	48 8b d7	 mov	 rdx, rdi
  00dc8	48 2b d1	 sub	 rdx, rcx
$LN335@inflateBac:

; 596  :                     copy = left;
; 597  :                 }
; 598  :                 if (copy > state->length) copy = state->length;

  00dcb	41 8b 47 50	 mov	 eax, DWORD PTR [r15+80]

; 599  :                 state->length -= copy;

  00dcf	44 3b c0	 cmp	 r8d, eax
  00dd2	8b c8		 mov	 ecx, eax
  00dd4	41 0f 46 c8	 cmovbe	 ecx, r8d
  00dd8	2b c1		 sub	 eax, ecx

; 600  :                 left -= copy;

  00dda	44 2b e1	 sub	 r12d, ecx
  00ddd	41 89 47 50	 mov	 DWORD PTR [r15+80], eax
  00de1	48 2b d7	 sub	 rdx, rdi
  00de4	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00de8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL252@inflateBac:

; 601  :                 do {
; 602  :                     *put++ = *from++;

  00df0	0f b6 04 3a	 movzx	 eax, BYTE PTR [rdx+rdi]
  00df4	88 07		 mov	 BYTE PTR [rdi], al
  00df6	48 ff c7	 inc	 rdi

; 603  :                 } while (--copy);

  00df9	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00dfc	75 f2		 jne	 SHORT $LL252@inflateBac

; 604  :             } while (state->length != 0);

  00dfe	48 89 7d c8	 mov	 QWORD PTR put$1$[rbp-120], rdi
  00e02	41 39 4f 50	 cmp	 DWORD PTR [r15+80], ecx
  00e06	0f 85 77 ff ff
	ff		 jne	 $LL246@inflateBac
$LN489@inflateBac:

; 284  :     hold = 0;
; 285  :     bits = 0;
; 286  :     put = state->window;
; 287  :     left = state->wsize;
; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00e0c	4c 8b 5d 28	 mov	 r11, QWORD PTR strm$[rbp-120]
$LN500@inflateBac:
  00e10	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
$LN499@inflateBac:
  00e14	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN393@inflateBac:
  00e18	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00e1c	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00e21	83 f8 12	 cmp	 eax, 18
  00e24	77 4c		 ja	 SHORT $LN341@inflateBac
  00e26	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
  00e2a	33 d2		 xor	 edx, edx
  00e2c	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00e30	e9 67 f2 ff ff	 jmp	 $LN502@inflateBac
$LN369@inflateBac:

; 622  :             goto inf_leave;
; 623  :         }
; 624  : 
; 625  :     /* Return unused input */
; 626  :   inf_leave:
; 627  :     strm->next_in = next;

  00e35	33 c0		 xor	 eax, eax
  00e37	44 8b c0	 mov	 r8d, eax
$LN503@inflateBac:
  00e3a	41 ba fb ff ff
	ff		 mov	 r10d, -5
  00e40	eb 36		 jmp	 SHORT $inf_leave$507
$LN337@inflateBac:

; 605  :             break;
; 606  : 
; 607  :         case DONE:
; 608  :             /* inflate stream terminated properly -- write leftover output */
; 609  :             ret = Z_STREAM_END;
; 610  :             if (left < state->wsize) {

  00e42	41 8b 47 34	 mov	 eax, DWORD PTR [r15+52]
  00e46	44 3b c8	 cmp	 r9d, eax
  00e49	73 2d		 jae	 SHORT $inf_leave$507

; 611  :                 if (out(out_desc, state->window, state->wsize - left))

  00e4b	49 8b 57 40	 mov	 rdx, QWORD PTR [r15+64]
  00e4f	41 2b c1	 sub	 eax, r9d
  00e52	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e56	44 8b c0	 mov	 r8d, eax
  00e59	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00e5c	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  00e60	85 c0		 test	 eax, eax
  00e62	75 d6		 jne	 SHORT $LN503@inflateBac
  00e64	44 8d 50 01	 lea	 r10d, QWORD PTR [rax+1]
  00e68	eb 0e		 jmp	 SHORT $inf_leave$507
$LN340@inflateBac:

; 612  :                     ret = Z_BUF_ERROR;
; 613  :             }
; 614  :             goto inf_leave;
; 615  : 
; 616  :         case BAD:
; 617  :             ret = Z_DATA_ERROR;

  00e6a	41 ba fd ff ff
	ff		 mov	 r10d, -3

; 618  :             goto inf_leave;

  00e70	eb 06		 jmp	 SHORT $inf_leave$507
$LN341@inflateBac:

; 619  : 
; 620  :         default:                /* can't happen, but makes compilers happy */
; 621  :             ret = Z_STREAM_ERROR;

  00e72	41 ba fe ff ff
	ff		 mov	 r10d, -2
$inf_leave$507:

; 622  :             goto inf_leave;
; 623  :         }
; 624  : 
; 625  :     /* Return unused input */
; 626  :   inf_leave:
; 627  :     strm->next_in = next;

  00e78	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]

; 628  :     strm->avail_in = have;
; 629  :     return ret;

  00e7c	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00e81	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00e86	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00e8b	89 58 08	 mov	 DWORD PTR [rax+8], ebx
  00e8e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00e93	4c 89 00	 mov	 QWORD PTR [rax], r8
  00e96	41 8b c2	 mov	 eax, r10d

; 630  : }

  00e99	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e9d	41 5f		 pop	 r15
  00e9f	41 5d		 pop	 r13
  00ea1	41 5c		 pop	 r12
  00ea3	5d		 pop	 rbp
  00ea4	c3		 ret	 0
$LN254@inflateBac:

; 274  :         return Z_STREAM_ERROR;

  00ea5	b8 fe ff ff ff	 mov	 eax, -2

; 630  : }

  00eaa	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00eae	41 5f		 pop	 r15
  00eb0	41 5d		 pop	 r13
  00eb2	41 5c		 pop	 r12
  00eb4	5d		 pop	 rbp
  00eb5	c3		 ret	 0
  00eb6	66 90		 npad	 2
$LN481@inflateBac:
  00eb8	00 00 00 00	 DD	 $LN255@inflateBac
  00ebc	00 00 00 00	 DD	 $LN341@inflateBac
  00ec0	00 00 00 00	 DD	 $LN31@inflateBac
  00ec4	00 00 00 00	 DD	 $LN341@inflateBac
  00ec8	00 00 00 00	 DD	 $LN341@inflateBac
  00ecc	00 00 00 00	 DD	 $LN56@inflateBac
  00ed0	00 00 00 00	 DD	 $LN341@inflateBac
  00ed4	00 00 00 00	 DD	 $LN341@inflateBac
  00ed8	00 00 00 00	 DD	 $LN341@inflateBac
  00edc	00 00 00 00	 DD	 $LN302@inflateBac
  00ee0	00 00 00 00	 DD	 $LN341@inflateBac
  00ee4	00 00 00 00	 DD	 $LN341@inflateBac
  00ee8	00 00 00 00	 DD	 $LN341@inflateBac
  00eec	00 00 00 00	 DD	 $LN341@inflateBac
  00ef0	00 00 00 00	 DD	 $LN341@inflateBac
  00ef4	00 00 00 00	 DD	 $LN341@inflateBac
  00ef8	00 00 00 00	 DD	 $LN341@inflateBac
  00efc	00 00 00 00	 DD	 $LN337@inflateBac
  00f00	00 00 00 00	 DD	 $LN340@inflateBac
inflateBack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File G:\1_Projects\BRDF\DisneyBRDF\zlib-1.2.12\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 634  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 635  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN3@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN3@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN3@inflateBac

; 637  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 638  :     strm->state = Z_NULL;
; 639  :     Tracev((stderr, "inflate: end\n"));
; 640  :     return Z_OK;

  00026	33 c0		 xor	 eax, eax
  00028	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 641  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN3@inflateBac:

; 636  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 641  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
